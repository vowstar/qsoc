// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: 2025 Huang Rui <vowstar@gmail.com>

#include "common/qsocgeneratemanager.h"
#include "common/qstaticstringweaver.h"

#include <QCoreApplication>
#include <QDebug>
#include <QDir>
#include <QFile>
#include <QFileInfo>
#include <QProcess>
#include <QRegularExpression>
#include <QTextStream>

#include <fstream>
#include <iostream>

bool QSocGenerateManager::generateVerilog(const QString &outputFileName)
{
    /* Check if netlistData is valid (instance section is now optional) */

    // Check if instance section exists and is valid when present
    if (netlistData["instance"] && !netlistData["instance"].IsMap()) {
        qCritical() << "Error: Invalid netlist data, 'instance' section is not a map";
        return false;
    }

    // Allow empty or missing instance section if comb, seq, or fsm section exists
    bool hasInstances = netlistData["instance"] && netlistData["instance"].IsMap()
                        && netlistData["instance"].size() > 0;
    bool hasCombSeqFsm = netlistData["comb"] || netlistData["seq"] || netlistData["fsm"];

    if (!hasInstances && !hasCombSeqFsm) {
        qCritical() << "Error: Invalid netlist data, no 'instance' section and no 'comb', "
                       "'seq', or 'fsm' section found";
        return false;
    }

    /* Check if net section exists and has valid format if present */
    if (netlistData["net"] && !netlistData["net"].IsMap()) {
        qCritical() << "Error: Invalid netlist data, 'net' section is not a map";
        return false;
    }

    /* Check if project manager is valid */
    if (!projectManager) {
        qCritical() << "Error: Project manager is null";
        return false;
    }

    if (!projectManager->isValidOutputPath(true)) {
        qCritical() << "Error: Invalid output path: " << projectManager->getOutputPath();
        return false;
    }

    /* Prepare output file path */
    const QString outputFilePath
        = QDir(projectManager->getOutputPath()).filePath(outputFileName + ".v");

    /* Open output file for writing */
    QFile outputFile(outputFilePath);
    if (!outputFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
        qCritical() << "Error: Failed to open output file for writing:" << outputFilePath;
        return false;
    }

    QTextStream out(&outputFile);

    /* Generate file header */
    out << "/**\n";
    out << " * @file " << outputFileName << ".v\n";
    out << " * @brief RTL implementation of " << outputFileName << "\n";
    out << " *\n";
    out << " * @details This file contains RTL implementation based on the input netlist.\n"
        << " *          Auto-generated RTL Verilog file. Generated by "
        << QCoreApplication::applicationName() << " " << QCoreApplication::applicationVersion()
        << ".\n";
    out << " * NOTE: Auto-generated file, do not edit manually.\n";
    out << " */\n\n";

    /* Generate module declaration */
    out << "module " << outputFileName;

    /* Add module parameters if they exist */
    if (netlistData["parameter"] && netlistData["parameter"].IsMap()
        && netlistData["parameter"].size() > 0) {
        out << " #(\n";
        QStringList paramDeclarations;

        for (auto paramIter = netlistData["parameter"].begin();
             paramIter != netlistData["parameter"].end();
             ++paramIter) {
            if (!paramIter->first.IsScalar()) {
                qWarning() << "Warning: Invalid parameter name, skipping";
                continue;
            }

            const QString paramName = QString::fromStdString(paramIter->first.as<std::string>());

            if (!paramIter->second.IsMap()) {
                qWarning() << "Warning: Parameter" << paramName << "has invalid format, skipping";
                continue;
            }

            /* Default to empty for Verilog 2001 */
            QString paramType  = "";
            QString paramValue = "";

            if (paramIter->second["type"] && paramIter->second["type"].IsScalar()) {
                paramType = QString::fromStdString(paramIter->second["type"].as<std::string>());
                /* Clean type for Verilog 2001 compatibility */
                paramType = QSocGenerateManager::cleanTypeForWireDeclaration(paramType);

                /* Add a space if type isn't empty after processing */
                if (!paramType.isEmpty() && !paramType.endsWith(" ")) {
                    paramType += " ";
                }
            }

            if (paramIter->second["value"] && paramIter->second["value"].IsScalar()) {
                paramValue = QString::fromStdString(paramIter->second["value"].as<std::string>());
            }

            paramDeclarations.append(
                QString("    parameter %1%2 = %3").arg(paramType).arg(paramName).arg(paramValue));
        }

        if (!paramDeclarations.isEmpty()) {
            out << paramDeclarations.join(",\n") << "\n";
        }
        out << ")";
    }

    /* Start port list */
    out << " (";

    /* Collect all ports for module interface */
    QStringList            ports;
    QMap<QString, QString> portToNetConnections; /* Map of port name to connected net name */

    /* Process port section if it exists */
    if (netlistData["port"] && netlistData["port"].IsMap()) {
        for (auto portIter = netlistData["port"].begin(); portIter != netlistData["port"].end();
             ++portIter) {
            if (!portIter->first.IsScalar()) {
                qWarning() << "Warning: Invalid port name, skipping";
                continue;
            }

            const QString portName = QString::fromStdString(portIter->first.as<std::string>());

            if (!portIter->second.IsMap()) {
                qWarning() << "Warning: Port" << portName << "has invalid format, skipping";
                continue;
            }

            QString direction = "input";
            QString type      = ""; /* Empty type by default for Verilog 2001 */

            if (portIter->second["direction"] && portIter->second["direction"].IsScalar()) {
                const QString dirStr = QString::fromStdString(
                                           portIter->second["direction"].as<std::string>())
                                           .toLower();

                /* Handle both full and abbreviated forms */
                if (dirStr == "out" || dirStr == "output") {
                    direction = "output";
                } else if (dirStr == "in" || dirStr == "input") {
                    direction = "input";
                } else if (dirStr == "inout") {
                    direction = "inout";
                }
            }

            /* Get port type/width information if present */
            if (portIter->second["type"] && portIter->second["type"].IsScalar()) {
                type = QString::fromStdString(portIter->second["type"].as<std::string>());
                /* Clean type for Verilog 2001 compatibility */
                type = QSocGenerateManager::cleanTypeForWireDeclaration(type);
            }

            /* Store the connection information if present */
            if (portIter->second["connect"] && portIter->second["connect"].IsScalar()) {
                const QString connectedNet = QString::fromStdString(
                    portIter->second["connect"].as<std::string>());
                portToNetConnections[portName] = connectedNet;
            }

            /* Add port declaration */
            ports.append(QString("%1 %2").arg(direction).arg(
                type.isEmpty() ? portName : type + " " + portName));
        }
    }

    /* Close module declaration */
    if (!ports.isEmpty()) {
        /* If we have parameters, add a comma after them */
        out << "\n    " << ports.join(",\n    ") << "\n";
    }
    out << ");\n\n";

    /* Build a mapping of all connections for each instance and port */
    QMap<QString, QMap<QString, QString>> instancePortConnections;

    /* First, create the instancePortConnections map with port connections */
    /* This needs to be done before wire generation to ensure port names are used */
    if (netlistData["net"] && netlistData["net"].IsMap()) {
        for (auto netIter = netlistData["net"].begin(); netIter != netlistData["net"].end();
             ++netIter) {
            if (!netIter->first.IsScalar()) {
                continue;
            }

            const QString netName = QString::fromStdString(netIter->first.as<std::string>());

            /* Check if this net is connected to a top-level port */
            QString connectedPortName;
            bool    connectedToTopPort = false;

            for (auto it = portToNetConnections.begin(); it != portToNetConnections.end(); ++it) {
                if (it.value() == netName) {
                    connectedToTopPort = true;
                    connectedPortName  = it.key();
                    break;
                }
            }

            try {
                /* Build connections using List format only */
                const YAML::Node &netNode = netIter->second;
                if (netNode.IsSequence()) {
                    /* Process List format connections */
                    for (const auto &connectionNode : netNode) {
                        if (!connectionNode.IsMap()) {
                            qWarning() << "Warning: Invalid connection node in net" << netName;
                            continue;
                        }

                        /* Get instance name */
                        if (!connectionNode["instance"] || !connectionNode["instance"].IsScalar()) {
                            qWarning()
                                << "Warning: No instance name in connection for net" << netName;
                            continue;
                        }
                        const QString instanceName = QString::fromStdString(
                            connectionNode["instance"].as<std::string>());

                        /* Get port name */
                        if (!connectionNode["port"] || !connectionNode["port"].IsScalar()) {
                            qWarning() << "Warning: No port name in connection for net" << netName;
                            continue;
                        }
                        const QString portName = QString::fromStdString(
                            connectionNode["port"].as<std::string>());

                        /* Check if this port has invert attribute */
                        bool hasInvert = false;
                        if (netlistData["instance"]
                            && netlistData["instance"][instanceName.toStdString()]
                            && netlistData["instance"][instanceName.toStdString()]["port"]
                            && netlistData["instance"][instanceName.toStdString()]["port"]
                                          [portName.toStdString()]) {
                            auto portNode = netlistData["instance"][instanceName.toStdString()]
                                                       ["port"][portName.toStdString()];
                            if (portNode.IsMap() && portNode["invert"]
                                && portNode["invert"].IsScalar()) {
                                /* Use direct YAML boolean parsing */
                                if (portNode["invert"].as<bool>()) {
                                    hasInvert = true;
                                }
                            }
                        }

                        /* Check if this port has bits selection attribute */
                        QString bitSelect = "";
                        if (connectionNode["bits"] && connectionNode["bits"].IsScalar()) {
                            bitSelect = QString::fromStdString(
                                connectionNode["bits"].as<std::string>());
                        }

                        /* If connected to top-level port, use the port name instead of net name */
                        if (connectedToTopPort) {
                            instancePortConnections[instanceName][portName]
                                = hasInvert ? QString("~%1%2")
                                                  .arg(connectedPortName)
                                                  .arg(bitSelect.isEmpty() ? "" : bitSelect)
                                            : QString("%1%2")
                                                  .arg(connectedPortName)
                                                  .arg(bitSelect.isEmpty() ? "" : bitSelect);
                        } else {
                            instancePortConnections[instanceName][portName]
                                = hasInvert ? QString("~%1%2").arg(netName).arg(
                                                  bitSelect.isEmpty() ? "" : bitSelect)
                                            : QString("%1%2").arg(netName).arg(
                                                  bitSelect.isEmpty() ? "" : bitSelect);
                        }
                    }
                } else {
                    qWarning() << "Warning: Net" << netName
                               << "is not in List format, skipping connections";
                }
            } catch (const std::exception &e) {
                qWarning() << "Error processing net:" << e.what();
            }
        }
    }

    /* Add connections (wires) section comment */
    out << "    /* Wire declarations */\n";

    /* Generate wire declarations FIRST */
    if (netlistData["net"]) {
        if (!netlistData["net"].IsMap()) {
            qWarning() << "Warning: 'net' section is not a map, skipping wire declarations";
        } else if (netlistData["net"].size() == 0) {
            qWarning() << "Warning: 'net' section is empty, no wire declarations to generate";
        } else {
            for (auto netIter = netlistData["net"].begin(); netIter != netlistData["net"].end();
                 ++netIter) {
                if (!netIter->first.IsScalar()) {
                    qWarning() << "Warning: Invalid net name, skipping";
                    continue;
                }

                const QString netName = QString::fromStdString(netIter->first.as<std::string>());

                if (!netIter->second) {
                    qWarning() << "Warning: Net" << netName << "has null data, skipping";
                    continue;
                }

                /* Net connections should be a sequence (list) of instance-port pairs */
                if (!netIter->second.IsSequence()) {
                    qWarning() << "Warning: Net" << netName << "is not a sequence, skipping";
                    continue;
                }

                const YAML::Node &connections = netIter->second;

                if (connections.size() == 0) {
                    qWarning() << "Warning: Net" << netName << "has no connections, skipping";
                    continue;
                }

                /* Build a list of instance-port pairs for width check */
                QList<PortConnection> portConnections;
                /* Collect detailed port information for each connection */
                QList<PortDetailInfo> portDetails;

                /* Check if this net is connected to a top-level port */
                bool    connectedToTopPort = false;
                QString connectedPortName;
                QString topLevelPortDirection = "unknown";

                /* Check if this net is connected to a top-level port */
                for (auto it = portToNetConnections.begin(); it != portToNetConnections.end();
                     ++it) {
                    if (it.value() == netName) {
                        connectedToTopPort = true;
                        connectedPortName  = it.key();

                        /* Get the port direction */
                        if (netlistData["port"]
                            && netlistData["port"][connectedPortName.toStdString()]
                            && netlistData["port"][connectedPortName.toStdString()]["direction"]
                            && netlistData["port"][connectedPortName.toStdString()]["direction"]
                                   .IsScalar()) {
                            const QString dirStr
                                = QString::fromStdString(
                                      netlistData["port"][connectedPortName.toStdString()]
                                                 ["direction"]
                                                     .as<std::string>())
                                      .toLower();

                            /* Store original direction for later use */
                            if (dirStr == "out" || dirStr == "output") {
                                topLevelPortDirection = "output";
                            } else if (dirStr == "in" || dirStr == "input") {
                                topLevelPortDirection = "input";
                            } else if (dirStr == "inout") {
                                topLevelPortDirection = "inout";
                            }

                            /* Reverse the direction for internal checking */
                            QString reversedDirection;
                            if (topLevelPortDirection == "output") {
                                reversedDirection
                                    = "input"; /* Top-level output is an input for internal nets */
                            } else if (topLevelPortDirection == "input") {
                                reversedDirection
                                    = "output"; /* Top-level input is an output for internal nets */
                            } else if (topLevelPortDirection == "inout") {
                                reversedDirection = "inout"; /* Bidirectional remains bidirectional */
                            }

                            /* Add top-level port to connection list */
                            portConnections.append(
                                PortConnection::createTopLevelPort(connectedPortName));

                            /* Get port width */
                            QString portWidthSpec = "";
                            QString portDirection = "unknown";

                            /* Get port direction */
                            if (netlistData["port"]
                                && netlistData["port"][connectedPortName.toStdString()]) {
                                auto portNode = netlistData["port"][connectedPortName.toStdString()];

                                /* Get port direction */
                                if (portNode["direction"] && portNode["direction"].IsScalar()) {
                                    const QString dirStr
                                        = QString::fromStdString(
                                              portNode["direction"].as<std::string>())
                                              .toLower();

                                    /* Handle both full and abbreviated forms */
                                    if (dirStr == "out" || dirStr == "output") {
                                        portDirection = "output";
                                    } else if (dirStr == "in" || dirStr == "input") {
                                        portDirection = "input";
                                    } else if (dirStr == "inout") {
                                        portDirection = "inout";
                                    }
                                }

                                /* Get port width/type */
                                if (portNode["type"] && portNode["type"].IsScalar()) {
                                    portWidthSpec = QString::fromStdString(
                                        portNode["type"].as<std::string>());
                                }
                            }

                            /* Initialize bitSelection as empty string */
                            const QString bitSelection = "";

                            /* Add to detailed port information with reversed direction */
                            portDetails.append(
                                PortDetailInfo::createTopLevelPort(
                                    connectedPortName,
                                    portWidthSpec,
                                    reversedDirection,
                                    bitSelection));
                        }
                        break;
                    }
                }

                /* Build port connections from netlistData */
                const YAML::Node &netNode = netlistData["net"][netName.toStdString()];
                if (netNode.IsSequence()) {
                    for (const auto &connectionNode : netNode) {
                        if (!connectionNode.IsMap()) {
                            qWarning() << "Warning: Invalid connection node in net" << netName;
                            continue;
                        }

                        /* Get instance name */
                        if (!connectionNode["instance"] || !connectionNode["instance"].IsScalar()) {
                            qWarning()
                                << "Warning: No instance name in connection for net" << netName;
                            continue;
                        }
                        const QString instanceName = QString::fromStdString(
                            connectionNode["instance"].as<std::string>());

                        /* Get port name */
                        if (!connectionNode["port"] || !connectionNode["port"].IsScalar()) {
                            qWarning() << "Warning: No port name in connection for net" << netName;
                            continue;
                        }
                        const QString portName = QString::fromStdString(
                            connectionNode["port"].as<std::string>());

                        /* Create a module port connection */
                        portConnections.append(
                            PortConnection::createModulePort(instanceName, portName));

                        /* Get additional details for this port */
                        QString portWidthSpec = "";
                        QString portDirection = "unknown";

                        /* Check if this port has bits selection attribute */
                        QString bitSelection = "";
                        if (connectionNode["bits"] && connectionNode["bits"].IsScalar()) {
                            bitSelection = QString::fromStdString(
                                connectionNode["bits"].as<std::string>());
                        }

                        /* Get instance's module */
                        if (netlistData["instance"][instanceName.toStdString()]
                            && netlistData["instance"][instanceName.toStdString()]["module"]
                            && netlistData["instance"][instanceName.toStdString()]["module"]
                                   .IsScalar()) {
                            const QString moduleName = QString::fromStdString(
                                netlistData["instance"][instanceName.toStdString()]["module"]
                                    .as<std::string>());

                            /* Get module definition */
                            if (moduleManager && moduleManager->isModuleExist(moduleName)) {
                                YAML::Node moduleData = moduleManager->getModuleYaml(moduleName);

                                if (moduleData["port"] && moduleData["port"].IsMap()
                                    && moduleData["port"][portName.toStdString()]) {
                                    /* Get port width */
                                    if (moduleData["port"][portName.toStdString()]["type"]
                                        && moduleData["port"][portName.toStdString()]["type"]
                                               .IsScalar()) {
                                        const QString originalType = QString::fromStdString(
                                            moduleData["port"][portName.toStdString()]["type"]
                                                .as<std::string>());
                                        /* Keep original type for width calculation, but clean for display */
                                        portWidthSpec = originalType;
                                    }

                                    /* Get port direction */
                                    if (moduleData["port"][portName.toStdString()]["direction"]
                                        && moduleData["port"][portName.toStdString()]["direction"]
                                               .IsScalar()) {
                                        portDirection = QString::fromStdString(
                                            moduleData["port"][portName.toStdString()]["direction"]
                                                .as<std::string>());
                                        /* Handle both full and abbreviated forms */
                                        if (portDirection == "out" || portDirection == "output") {
                                            portDirection = "output";
                                        } else if (portDirection == "in" || portDirection == "input") {
                                            portDirection = "input";
                                        } else if (portDirection == "inout") {
                                            portDirection = "inout";
                                        }
                                    }
                                }
                            }
                        }

                        /* Add to detailed port information */
                        portDetails.append(
                            PortDetailInfo::createModulePort(
                                instanceName, portName, portWidthSpec, portDirection, bitSelection));
                    }
                }

                /* Add comb/seq/fsm outputs as additional drivers for this net */
                QList<PortDetailInfo> combSeqFsmOutputs = collectCombSeqFsmOutputs();
                for (const PortDetailInfo &combOutput : combSeqFsmOutputs) {
                    // Check if this comb/seq/fsm output drives the current net
                    QString outputBaseName  = combOutput.portName;
                    QString outputBitSelect = combOutput.bitSelect;

                    // If output has bit selection, it affects only part of the signal
                    // If no bit selection, it affects the full signal
                    bool drivesThisNet = false;

                    if (outputBaseName == netName) {
                        drivesThisNet = true;
                    } else if (connectedToTopPort && outputBaseName == connectedPortName) {
                        drivesThisNet = true;
                    }

                    if (drivesThisNet) {
                        // Add this comb/seq/fsm output as a driver
                        // Include bit selection in the port name if it exists
                        QString fullSignalName = outputBaseName;
                        if (!outputBitSelect.isEmpty()) {
                            fullSignalName = outputBaseName + outputBitSelect;
                        }
                        portConnections.append(PortConnection::createCombSeqFsmPort(fullSignalName));

                        portDetails.append(
                            PortDetailInfo::createTopLevelPort(
                                outputBaseName,
                                combOutput.width,
                                "output", // comb/seq/fsm outputs are always output drivers
                                outputBitSelect));
                    }
                }

                /* Check port width consistency */
                const bool hasWidthMismatch = !checkPortWidthConsistency(portConnections);
                if (hasWidthMismatch) {
                    qWarning() << "Warning: Port width mismatch detected for net" << netName;
                }

                /* Check port direction consistency */
                const PortDirectionStatus dirStatus = checkPortDirectionConsistency(portConnections);
                const bool isUndriven   = (dirStatus == PortDirectionStatus::Undriven);
                const bool isMultidrive = (dirStatus == PortDirectionStatus::Multidrive);

                if (isUndriven) {
                    qWarning() << "Warning: Net" << netName
                               << "has only input ports, missing driver";
                } else if (isMultidrive) {
                    qWarning() << "Warning: Net" << netName << "has multiple output/inout ports";
                }

                /* Generate combined warning comments for the net */
                if (hasWidthMismatch || isUndriven || isMultidrive) {
                    /* Output width mismatch warning if detected */
                    if (hasWidthMismatch) {
                        if (connectedToTopPort) {
                            out << "    /* FIXME: Port " << connectedPortName << " (net " << netName
                                << ") width mismatch - please check connected ports:\n";
                        } else {
                            out << "    /* FIXME: Net " << netName
                                << " width mismatch - please check connected ports:\n";
                        }

                        /* Add detailed information for each connected port */
                        for (const auto &detail : portDetails) {
                            /* Clean width information for display */
                            QString displayWidth
                                = detail.width.isEmpty()
                                      ? "default"
                                      : QSocGenerateManager::cleanTypeForWireDeclaration(
                                            detail.width);
                            if (displayWidth.isEmpty() && !detail.width.isEmpty()) {
                                displayWidth
                                    = "default"; /* fallback for single-bit types like "logic" */
                            }

                            if (detail.type == PortType::TopLevel) {
                                /* For top-level ports, we need to display the original direction, not the reversed one */
                                QString displayDirection = detail.direction;
                                /* input -> output, output -> input, inout -> inout */
                                if (displayDirection == "input") {
                                    displayDirection = "output";
                                } else if (displayDirection == "output") {
                                    displayDirection = "input";
                                }

                                QString sourceType = "Top-Level Port";

                                // Check if this is a comb/seq/fsm output
                                QList<PortDetailInfo> combSeqFsmOutputs = collectCombSeqFsmOutputs();
                                for (const PortDetailInfo &combOutput : combSeqFsmOutputs) {
                                    if (combOutput.portName == detail.portName
                                        && combOutput.bitSelect == detail.bitSelect) {
                                        sourceType = "Comb/Seq/FSM Output";
                                        break;
                                    }
                                }

                                out << "     *   " << sourceType << ": " << detail.portName
                                    << ", Direction: " << displayDirection
                                    << ", Width: " << displayWidth
                                    << (detail.bitSelect.isEmpty()
                                            ? ""
                                            : ", Bit Selection: " + detail.bitSelect)
                                    << "\n";
                            } else {
                                /* Regular instance port */
                                if (netlistData["instance"][detail.instanceName.toStdString()]
                                    && netlistData["instance"][detail.instanceName.toStdString()]
                                                  ["module"]
                                    && netlistData["instance"][detail.instanceName.toStdString()]
                                                  ["module"]
                                                      .IsScalar()) {
                                    out << "     *   Module: "
                                        << netlistData["instance"]
                                                      [detail.instanceName.toStdString()]["module"]
                                                          .as<std::string>()
                                                          .c_str()
                                        << ", Instance: " << detail.instanceName
                                        << ", Port: " << detail.portName
                                        << ", Direction: " << detail.direction
                                        << ", Width: " << displayWidth
                                        << (detail.bitSelect.isEmpty()
                                                ? ""
                                                : ", Bit Selection: " + detail.bitSelect)
                                        << "\n";
                                } else {
                                    /* Handle case where instance data might be invalid */
                                    out << "     *   Instance: " << detail.instanceName
                                        << ", Port: " << detail.portName
                                        << ", Direction: " << detail.direction
                                        << ", Width: " << displayWidth
                                        << (detail.bitSelect.isEmpty()
                                                ? ""
                                                : ", Bit Selection: " + detail.bitSelect)
                                        << "\n";
                                }
                            }
                        }
                        out << "     */\n";
                    }

                    /* Output undriven warning if detected */
                    if (isUndriven) {
                        if (connectedToTopPort) {
                            out << "    /* FIXME: Port " << connectedPortName << " (net " << netName
                                << ") is undriven - missing source:\n";
                        } else {
                            out << "    /* FIXME: Net " << netName
                                << " is undriven - missing source:\n";
                        }

                        /* Add detailed information for each connected port */
                        for (const auto &detail : portDetails) {
                            /* Clean width information for display */
                            QString displayWidth
                                = detail.width.isEmpty()
                                      ? "default"
                                      : QSocGenerateManager::cleanTypeForWireDeclaration(
                                            detail.width);
                            if (displayWidth.isEmpty() && !detail.width.isEmpty()) {
                                displayWidth
                                    = "default"; /* fallback for single-bit types like "logic" */
                            }

                            if (detail.type == PortType::TopLevel) {
                                /* For top-level ports, we need to display the original direction, not the reversed one */
                                QString displayDirection = detail.direction;
                                if (displayDirection == "input") {
                                    displayDirection = "output";
                                } else if (displayDirection == "output") {
                                    displayDirection = "input";
                                }
                                /* inout remains inout */

                                QString sourceType = "Top-Level Port";

                                // Check if this is a comb/seq/fsm output
                                QList<PortDetailInfo> combSeqFsmOutputs = collectCombSeqFsmOutputs();
                                for (const PortDetailInfo &combOutput : combSeqFsmOutputs) {
                                    if (combOutput.portName == detail.portName
                                        && combOutput.bitSelect == detail.bitSelect) {
                                        sourceType = "Comb/Seq/FSM Output";
                                        break;
                                    }
                                }

                                out << "     *   " << sourceType << ": " << detail.portName
                                    << ", Direction: " << displayDirection
                                    << ", Width: " << displayWidth
                                    << (detail.bitSelect.isEmpty()
                                            ? ""
                                            : ", Bit Selection: " + detail.bitSelect)
                                    << "\n";
                            } else {
                                /* Regular instance port */
                                if (netlistData["instance"][detail.instanceName.toStdString()]
                                    && netlistData["instance"][detail.instanceName.toStdString()]
                                                  ["module"]
                                    && netlistData["instance"][detail.instanceName.toStdString()]
                                                  ["module"]
                                                      .IsScalar()) {
                                    out << "     *   Module: "
                                        << netlistData["instance"]
                                                      [detail.instanceName.toStdString()]["module"]
                                                          .as<std::string>()
                                                          .c_str()
                                        << ", Instance: " << detail.instanceName
                                        << ", Port: " << detail.portName
                                        << ", Direction: " << detail.direction
                                        << ", Width: " << displayWidth
                                        << (detail.bitSelect.isEmpty()
                                                ? ""
                                                : ", Bit Selection: " + detail.bitSelect)
                                        << "\n";
                                } else {
                                    /* Handle case where instance data might be invalid */
                                    out << "     *   Instance: " << detail.instanceName
                                        << ", Port: " << detail.portName
                                        << ", Direction: " << detail.direction
                                        << ", Width: " << displayWidth
                                        << (detail.bitSelect.isEmpty()
                                                ? ""
                                                : ", Bit Selection: " + detail.bitSelect)
                                        << "\n";
                                }
                            }
                        }
                        out << "     */\n";
                    }

                    /* Output multidrive warning if detected */
                    if (isMultidrive) {
                        if (connectedToTopPort) {
                            out << "    /* FIXME: Port " << connectedPortName << " (net " << netName
                                << ") has multiple drivers - potential conflict:\n";
                        } else {
                            out << "    /* FIXME: Net " << netName
                                << " has multiple drivers - potential conflict:\n";
                        }

                        /* Add detailed information for each connected port */
                        for (const auto &detail : portDetails) {
                            /* Clean width information for display */
                            QString displayWidth
                                = detail.width.isEmpty()
                                      ? "default"
                                      : QSocGenerateManager::cleanTypeForWireDeclaration(
                                            detail.width);
                            if (displayWidth.isEmpty() && !detail.width.isEmpty()) {
                                displayWidth
                                    = "default"; /* fallback for single-bit types like "logic" */
                            }

                            if (detail.type == PortType::TopLevel) {
                                /* For top-level ports, we need to display the original direction, not the reversed one */
                                QString displayDirection = detail.direction;
                                if (displayDirection == "input") {
                                    displayDirection = "output";
                                } else if (displayDirection == "output") {
                                    displayDirection = "input";
                                }
                                /* inout remains inout */

                                QString sourceType = "Top-Level Port";

                                // Check if this is a comb/seq/fsm output
                                QList<PortDetailInfo> combSeqFsmOutputs = collectCombSeqFsmOutputs();
                                for (const PortDetailInfo &combOutput : combSeqFsmOutputs) {
                                    if (combOutput.portName == detail.portName
                                        && combOutput.bitSelect == detail.bitSelect) {
                                        sourceType = "Comb/Seq/FSM Output";
                                        break;
                                    }
                                }

                                out << "     *   " << sourceType << ": " << detail.portName
                                    << ", Direction: " << displayDirection
                                    << ", Width: " << displayWidth
                                    << (detail.bitSelect.isEmpty()
                                            ? ""
                                            : ", Bit Selection: " + detail.bitSelect)
                                    << "\n";
                            } else {
                                /* Regular instance port */
                                if (netlistData["instance"][detail.instanceName.toStdString()]
                                    && netlistData["instance"][detail.instanceName.toStdString()]
                                                  ["module"]
                                    && netlistData["instance"][detail.instanceName.toStdString()]
                                                  ["module"]
                                                      .IsScalar()) {
                                    out << "     *   Module: "
                                        << netlistData["instance"]
                                                      [detail.instanceName.toStdString()]["module"]
                                                          .as<std::string>()
                                                          .c_str()
                                        << ", Instance: " << detail.instanceName
                                        << ", Port: " << detail.portName
                                        << ", Direction: " << detail.direction
                                        << ", Width: " << displayWidth
                                        << (detail.bitSelect.isEmpty()
                                                ? ""
                                                : ", Bit Selection: " + detail.bitSelect)
                                        << "\n";
                                } else {
                                    /* Handle case where instance data might be invalid */
                                    out << "     *   Instance: " << detail.instanceName
                                        << ", Port: " << detail.portName
                                        << ", Direction: " << detail.direction
                                        << ", Width: " << displayWidth
                                        << (detail.bitSelect.isEmpty()
                                                ? ""
                                                : ", Bit Selection: " + detail.bitSelect)
                                        << "\n";
                                }
                            }
                        }
                        out << "     */\n";
                    }
                }

                /* Only declare wire if not connected to top-level port to avoid redundancy */
                if (!connectedToTopPort) {
                    /* Get net width from all ports connected to this net */
                    QString netWidth = "";
                    int     maxWidth = 0;

                    /* Find the maximum bit index needed for this net based on port widths */
                    int maxBitIndex = -1;

                    for (const auto &detail : portDetails) {
                        int requiredMaxBit = -1;

                        /* Always check the port's original width first */
                        if (!detail.width.isEmpty()) {
                            /* Check if it's a single bit type (logic, wire) */
                            if (detail.width == "logic" || detail.width == "wire") {
                                /* Single bit port - wire should be single bit regardless of bit selection */
                                requiredMaxBit = 0;
                            } else {
                                /* Attempt to extract width value from format like [31:0] or [7] */
                                const QRegularExpression widthRegex(
                                    R"(\[\s*(\d+)\s*(?::\s*(\d+))?\s*\])");
                                const QRegularExpressionMatch match = widthRegex.match(detail.width);
                                if (match.hasMatch()) {
                                    bool      msb_ok = false;
                                    const int msb    = match.captured(1).toInt(&msb_ok);

                                    if (msb_ok) {
                                        requiredMaxBit = msb;
                                    }
                                }
                            }
                        }

                        /* If no port width found, fall back to bit selection */
                        /* Note: This fallback should only be used when port width is unknown */
                        if (requiredMaxBit == -1 && !detail.bitSelect.isEmpty()) {
                            /* Parse bit selection like [7:4], [3:0], or [5] */
                            const QRegularExpression bitSelectRegex(
                                R"(\[\s*(\d+)\s*(?::\s*(\d+))?\s*\])");
                            const QRegularExpressionMatch bitMatch = bitSelectRegex.match(
                                detail.bitSelect);
                            if (bitMatch.hasMatch()) {
                                bool      msb_ok = false;
                                const int msb    = bitMatch.captured(1).toInt(&msb_ok);
                                if (msb_ok) {
                                    if (bitMatch.capturedLength(2) > 0) {
                                        /* Range selection like [7:4] - we need up to MSB */
                                        requiredMaxBit = msb;
                                    } else {
                                        /* Single bit selection like [5] - we need up to that bit */
                                        requiredMaxBit = msb;
                                    }
                                }
                            }
                        }

                        /* Update the maximum bit index needed */
                        if (requiredMaxBit > maxBitIndex) {
                            maxBitIndex = requiredMaxBit;
                        }
                    }

                    /* Generate the net width specification */
                    if (maxBitIndex >= 0) {
                        if (maxBitIndex == 0) {
                            /* Single bit, no range needed */
                            netWidth = "";
                        } else {
                            /* Multi-bit, generate [msb:0] format */
                            netWidth = QString("[%1:0]").arg(maxBitIndex);
                        }
                        maxWidth = maxBitIndex + 1;
                    }

                    /* If no width found from ports, try from net type as fallback */
                    if (netWidth.isEmpty() && netlistData["net"]
                        && netlistData["net"][netName.toStdString()]
                        && netlistData["net"][netName.toStdString()]["type"]
                        && netlistData["net"][netName.toStdString()]["type"].IsScalar()) {
                        netWidth = QString::fromStdString(
                            netlistData["net"][netName.toStdString()]["type"].as<std::string>());
                    }

                    /* Add wire declaration for this net with width information if available */
                    if (!netWidth.isEmpty()) {
                        /* Clean the type string to remove unwanted keywords like 'reg', 'logic', etc. */
                        const QString cleanedWidth
                            = QSocGenerateManager::cleanTypeForWireDeclaration(netWidth);
                        if (!cleanedWidth.isEmpty()) {
                            out << "    wire " << cleanedWidth << " " << netName << ";\n";
                        } else {
                            out << "    wire " << netName << ";\n";
                        }
                    } else {
                        out << "    wire " << netName << ";\n";
                    }
                } else {
                    /* Check for width mismatches between port and net */
                    QString portWidth     = "";
                    QString netWidth      = "";
                    QString portDirection = "input";

                    /* Get port information */
                    if (netlistData["port"]
                        && netlistData["port"][connectedPortName.toStdString()]) {
                        auto portNode = netlistData["port"][connectedPortName.toStdString()];

                        /* Get port direction */
                        if (portNode["direction"] && portNode["direction"].IsScalar()) {
                            const QString dirStr = QString::fromStdString(
                                                       portNode["direction"].as<std::string>())
                                                       .toLower();

                            /* Handle both full and abbreviated forms */
                            if (dirStr == "out" || dirStr == "output") {
                                portDirection = "output";
                            } else if (dirStr == "in" || dirStr == "input") {
                                portDirection = "input";
                            } else if (dirStr == "inout") {
                                portDirection = "inout";
                            }
                        }

                        /* Get port width/type */
                        if (portNode["type"] && portNode["type"].IsScalar()) {
                            portWidth = QString::fromStdString(portNode["type"].as<std::string>());
                        }
                    }

                    /* Get net width */
                    if (netlistData["net"] && netlistData["net"][netName.toStdString()]
                        && netlistData["net"][netName.toStdString()]["type"]
                        && netlistData["net"][netName.toStdString()]["type"].IsScalar()) {
                        netWidth = QString::fromStdString(
                            netlistData["net"][netName.toStdString()]["type"].as<std::string>());
                    }

                    /* Check width compatibility */
                    const bool widthMismatch = !portWidth.isEmpty() && !netWidth.isEmpty()
                                               && portWidth != netWidth;

                    /* Add width mismatch FIXME comment if needed */
                    if (widthMismatch) {
                        out << "    /* FIXME: Port " << connectedPortName << " (net " << netName
                            << ") width mismatch - port width: " << portWidth
                            << ", net width: " << netWidth << " */\n";
                    }

                    /* Note: Removed inout bidirectional behavior warning - this is normal for uplink connections */
                }
            }
            out << "\n";
        }
    } else {
        qWarning()
            << "Warning: No 'net' section in netlist, no wire declarations will be generated";
    }

    /* Add instances section comment */
    out << "    /* Module instantiations */\n";

    /* Generate instance declarations after wire declarations */
    if (netlistData["instance"] && netlistData["instance"].IsMap()) {
        for (auto instanceIter = netlistData["instance"].begin();
             instanceIter != netlistData["instance"].end();
             ++instanceIter) {
            /* Check if the instance name is a scalar */
            if (!instanceIter->first.IsScalar()) {
                qWarning() << "Warning: Invalid instance name, skipping";
                continue;
            }

            const QString instanceName = QString::fromStdString(
                instanceIter->first.as<std::string>());

            /* Check if the instance data is valid */
            if (!instanceIter->second || !instanceIter->second.IsMap()) {
                qWarning() << "Warning: Invalid instance data for" << instanceName
                           << "(not a map), skipping";
                continue;
            }

            const YAML::Node &instanceData = instanceIter->second;

            if (!instanceData["module"] || !instanceData["module"].IsScalar()) {
                qWarning() << "Warning: Invalid module name for instance" << instanceName;
                continue;
            }

            const QString moduleName = QString::fromStdString(
                instanceData["module"].as<std::string>());

            /* Generate instance declaration with parameters if any */
            out << "    " << moduleName << " ";

            /* Add parameters if they exist */
            if (instanceData["parameter"]) {
                if (!instanceData["parameter"].IsMap()) {
                    qWarning() << "Warning: 'parameter' section for instance" << instanceName
                               << "is not a map, ignoring";
                } else if (instanceData["parameter"].size() == 0) {
                    qWarning() << "Warning: 'parameter' section for instance" << instanceName
                               << "is empty, ignoring";
                } else {
                    out << "#(\n";

                    QStringList paramList;
                    for (auto paramIter = instanceData["parameter"].begin();
                         paramIter != instanceData["parameter"].end();
                         ++paramIter) {
                        if (!paramIter->first.IsScalar()) {
                            qWarning()
                                << "Warning: Invalid parameter name in instance" << instanceName;
                            continue;
                        }

                        if (!paramIter->second.IsScalar()) {
                            qWarning() << "Warning: Parameter"
                                       << QString::fromStdString(paramIter->first.as<std::string>())
                                       << "in instance" << instanceName
                                       << "has a non-scalar value, skipping";
                            continue;
                        }

                        const QString paramName = QString::fromStdString(
                            paramIter->first.as<std::string>());
                        const QString paramValue = QString::fromStdString(
                            paramIter->second.as<std::string>());

                        paramList.append(QString("        .%1(%2)").arg(paramName).arg(paramValue));
                    }

                    out << paramList.join(",\n") << "\n    ) ";
                }
            }

            out << instanceName << " (\n";

            /* Get the port connections for this instance */
            QStringList portConnections;

            /* Get module definition to ensure all ports are listed */
            if (moduleManager && moduleManager->isModuleExist(moduleName)) {
                YAML::Node moduleData = moduleManager->getModuleYaml(moduleName);

                if (moduleData["port"] && moduleData["port"].IsMap()) {
                    /* Get the existing connections map for this instance */
                    QMap<QString, QString> portMap;
                    if (instancePortConnections.contains(instanceName)) {
                        portMap = instancePortConnections[instanceName];
                    }

                    /* Iterate through all ports in the module definition */
                    for (auto portIter = moduleData["port"].begin();
                         portIter != moduleData["port"].end();
                         ++portIter) {
                        if (!portIter->first.IsScalar()) {
                            qWarning() << "Warning: Invalid port name in module" << moduleName;
                            continue;
                        }

                        const QString portName = QString::fromStdString(
                            portIter->first.as<std::string>());

                        /* Check if this port has a connection */
                        if (portMap.contains(portName)) {
                            const QString wireConnection = portMap[portName];
                            portConnections.append(
                                QString("        .%1(%2)").arg(portName).arg(wireConnection));
                        } else {
                            /* Port exists in module but has no connection */
                            QString direction = "signal";
                            QString width     = "";

                            if (portIter->second && portIter->second["direction"]
                                && portIter->second["direction"].IsScalar()) {
                                direction = QString::fromStdString(
                                    portIter->second["direction"].as<std::string>());
                            }

                            /* Get port width/type */
                            if (portIter->second && portIter->second["type"]
                                && portIter->second["type"].IsScalar()) {
                                QString type = QString::fromStdString(
                                    portIter->second["type"].as<std::string>());

                                /* Clean type for Verilog 2001 compatibility */
                                type = QSocGenerateManager::cleanTypeForWireDeclaration(type);

                                /* Extract width information if it exists in format [x:y] or [x] */
                                const QRegularExpression widthRegex(
                                    R"(\[\s*(\d+)\s*(?::\s*(\d+))?\s*\])");
                                const QRegularExpressionMatch match = widthRegex.match(type);
                                if (match.hasMatch()) {
                                    /* Both [x] and [x:y] formats use the full match */
                                    width = match.captured(0);
                                }
                            }

                            /* Check for tie attribute in instance's port */
                            bool    hasTie = false;
                            QString tieValue;
                            int     portWidth = 1; /* Default width if not specified */

                            /* Extract port width for bit size validation */
                            if (!width.isEmpty()) {
                                const QRegularExpression widthRegex(R"(\[(\d+)(?::(\d+))?\])");
                                auto                     match = widthRegex.match(width);
                                if (match.hasMatch()) {
                                    bool      msb_ok = false;
                                    const int msb    = match.captured(1).toInt(&msb_ok);
                                    if (msb_ok) {
                                        if (match.capturedLength(2) > 0) {
                                            /* Case with specified LSB, e.g. [7:3] */
                                            bool      lsb_ok = false;
                                            const int lsb    = match.captured(2).toInt(&lsb_ok);
                                            if (lsb_ok) {
                                                portWidth = qAbs(msb - lsb) + 1;
                                            } else {
                                                portWidth = msb
                                                            + 1; /* Fallback to default handling */
                                            }
                                        } else {
                                            /* Case with only MSB specified, e.g. [7] */
                                            portWidth = msb + 1; /* [7] means 8 bits [7:0] */
                                        }
                                    }
                                }
                            }

                            /* Check if this port is already connected to any net in the design */
                            bool isConnectedToNet = false;
                            if (netlistData["net"] && netlistData["net"].IsMap()) {
                                for (auto netIter = netlistData["net"].begin();
                                     netIter != netlistData["net"].end() && !isConnectedToNet;
                                     ++netIter) {
                                    if (netIter->second.IsSequence()) {
                                        for (const auto &connectionNode : netIter->second) {
                                            if (connectionNode.IsMap() && connectionNode["instance"]
                                                && connectionNode["instance"].IsScalar()
                                                && connectionNode["port"]
                                                && connectionNode["port"].IsScalar()) {
                                                const QString connectedInstance
                                                    = QString::fromStdString(
                                                        connectionNode["instance"].as<std::string>());
                                                const QString connectedPort = QString::fromStdString(
                                                    connectionNode["port"].as<std::string>());

                                                if (connectedInstance == instanceName
                                                    && connectedPort == portName) {
                                                    isConnectedToNet = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            /* Only proceed with tie if port is not connected to a net */
                            if (!isConnectedToNet) {
                                /* Check if instance has tie attribute for this port */
                                if (netlistData["instance"]
                                    && netlistData["instance"][instanceName.toStdString()]
                                    && netlistData["instance"][instanceName.toStdString()]["port"]
                                    && netlistData["instance"][instanceName.toStdString()]["port"]
                                                  [portName.toStdString()]) {
                                    auto portNode
                                        = netlistData["instance"][instanceName.toStdString()]
                                                     ["port"][portName.toStdString()];

                                    /* Check for tie attribute (only if portNode is a map) */
                                    if (portNode.IsMap() && portNode["tie"]
                                        && portNode["tie"].IsScalar()) {
                                        const QString tieStr = QString::fromStdString(
                                            portNode["tie"].as<std::string>());

                                        /* Parse the tie value using our number parser */
                                        const QSocNumberInfo numInfo = parseNumber(tieStr);

                                        /* Only apply tie to input ports */
                                        if (direction.toLower() == "input"
                                            || direction.toLower() == "in") {
                                            hasTie = true;

                                            /* Format the tie value */
                                            /* Create a copy of numInfo with adjusted width */
                                            QSocNumberInfo adjustedInfo = numInfo;

                                            /* Special handling for overflow detection */
                                            if (numInfo.errorDetected) {
                                                /* For overflow values, keep the original string representation */
                                                if (numInfo.width > portWidth) {
                                                    tieValue
                                                        = QString(
                                                              "%1 /* FIXME: Value width %2 bits "
                                                              "exceeds port width %3 bits */")
                                                              .arg(numInfo.originalString)
                                                              .arg(numInfo.width)
                                                              .arg(portWidth);
                                                } else {
                                                    tieValue = numInfo.originalString;
                                                }
                                            } else {
                                                /* Normal handling for regular values */
                                                adjustedInfo.width            = portWidth;
                                                adjustedInfo.hasExplicitWidth = true;

                                                /* Create a mask for the width */
                                                BigUnsigned mask = BigUnsigned(0);
                                                for (int i = 0; i < portWidth; i++) {
                                                    mask = (mask << 1) + BigUnsigned(1);
                                                }
                                                /* Apply mask to truncate the value */
                                                if (adjustedInfo.value.getSign()
                                                    == BigInteger::negative) {
                                                    /* For negative numbers, apply mask to magnitude and maintain sign */
                                                    const BigUnsigned result
                                                        = adjustedInfo.value.getMagnitude() & mask;
                                                    adjustedInfo.value
                                                        = BigInteger(result, BigInteger::negative);
                                                } else {
                                                    /* For non-negative numbers, just apply the mask */
                                                    adjustedInfo.value = BigInteger(
                                                        adjustedInfo.value.getMagnitude() & mask);
                                                }

                                                if (numInfo.width > portWidth) {
                                                    /* Value is wider than port - show FIXME comment but use proper width */
                                                    tieValue
                                                        = QString(
                                                              "%1 /* FIXME: Value %2 wider than "
                                                              "port width %3 bits */")
                                                              .arg(adjustedInfo.formatVerilog())
                                                              .arg(numInfo.formatVerilog())
                                                              .arg(portWidth);
                                                } else {
                                                    /* Use adjusted formatting with correct width, preserving original base */
                                                    tieValue = adjustedInfo.formatVerilog();
                                                }
                                            }

                                            /* Check for invert attribute */
                                            if (portNode.IsMap() && portNode["invert"]
                                                && portNode["invert"].IsScalar()) {
                                                /* Use direct YAML boolean parsing instead of string conversion */
                                                if (portNode["invert"].as<bool>()) {
                                                    /* If we need to invert, apply logical NOT (~) to the value */
                                                    tieValue = QString("~(%1)").arg(tieValue);
                                                }
                                            }
                                        } else {
                                            /* Add warning for non-input ports with tie */
                                            tieValue
                                                = QString(
                                                      "/* FIXME: 'tie' attribute for %1 port %2 "
                                                      "ignored */")
                                                      .arg(direction.toLower())
                                                      .arg(portName);
                                        }
                                    }
                                    /* If no tie but has invert attribute on an input port, warn about missing tie */
                                    else if (
                                        portNode.IsMap() && portNode["invert"]
                                        && portNode["invert"].IsScalar()
                                        && (direction.toLower() == "input"
                                            || direction.toLower() == "in")) {
                                        tieValue = QString(
                                                       "/* FIXME: 'invert' attribute on %1 port %2 "
                                                       "without 'tie' attribute */")
                                                       .arg(direction.toLower())
                                                       .arg(portName);
                                    }
                                }
                            }

                            /* Format port connection based on connection status and tie attribute */
                            if (hasTie
                                && (direction.toLower() == "input" || direction.toLower() == "in")) {
                                portConnections.append(
                                    QString("        .%1(%2)").arg(portName).arg(tieValue));
                            } else if (
                                isConnectedToNet && instancePortConnections.contains(instanceName)
                                && instancePortConnections[instanceName].contains(portName)) {
                                /* Use connection from instancePortConnections if port is connected to a net */
                                const QString connectionValue
                                    = instancePortConnections[instanceName][portName];
                                portConnections.append(
                                    QString("        .%1(%2)").arg(portName).arg(connectionValue));
                            } else {
                                /* Format FIXME message with width if available */
                                if (width.isEmpty()) {
                                    portConnections.append(
                                        QString("        .%1(/* FIXME: %2 %3 missing */)")
                                            .arg(portName)
                                            .arg(direction)
                                            .arg(portName));
                                } else {
                                    portConnections.append(
                                        QString("        .%1(/* FIXME: %2 %3 %4 missing */)")
                                            .arg(portName)
                                            .arg(direction)
                                            .arg(width)
                                            .arg(portName));
                                }
                            }
                        }
                    }
                } else {
                    qWarning() << "Warning: Module" << moduleName << "has no valid port section";
                }
            } else {
                qWarning() << "Warning: Failed to get module definition for" << moduleName;

                /* Fall back to existing connections if module definition not available */
                if (instancePortConnections.contains(instanceName)) {
                    const QMap<QString, QString>  &portMap = instancePortConnections[instanceName];
                    QMapIterator<QString, QString> portIter(portMap);
                    while (portIter.hasNext()) {
                        portIter.next();
                        portConnections.append(
                            QString("        .%1(%2)").arg(portIter.key()).arg(portIter.value()));
                    }
                }
            }

            if (portConnections.isEmpty()) {
                /* No port connections found for this instance */
                out << "        /* No port connections found for this instance */\n";
            } else {
                out << portConnections.join(",\n") << "\n";
            }

            out << "    );\n";
        }
    }

    /* Generate combinational logic after module instantiations */
    if (netlistData["comb"] && netlistData["comb"].IsSequence() && netlistData["comb"].size() > 0) {
        /* First pass: collect all outputs that need internal reg declarations */
        QSet<QString> alwaysBlockOutputs;
        for (size_t i = 0; i < netlistData["comb"].size(); ++i) {
            const YAML::Node &combItem = netlistData["comb"][i];
            if (!combItem.IsMap() || !combItem["out"] || !combItem["out"].IsScalar()) {
                continue;
            }
            const QString outputSignal = QString::fromStdString(combItem["out"].as<std::string>());

            /* Check if this output needs an always block */
            if ((combItem["if"] && combItem["if"].IsSequence())
                || (combItem["case"] && combItem["case"].IsScalar() && combItem["cases"]
                    && combItem["cases"].IsMap())) {
                alwaysBlockOutputs.insert(outputSignal);
            }
        }

        /* Generate internal reg declarations for always block outputs */
        if (!alwaysBlockOutputs.isEmpty()) {
            out << "\n    /* Internal reg declarations for combinational logic */\n";
            for (const QString &outputSignal : alwaysBlockOutputs) {
                /* Find the port width for this output signal */
                QString regWidth = "";
                if (netlistData["port"] && netlistData["port"].IsMap()) {
                    for (const auto &portEntry : netlistData["port"]) {
                        if (portEntry.first.IsScalar()
                            && QString::fromStdString(portEntry.first.as<std::string>())
                                   == outputSignal) {
                            if (portEntry.second.IsMap() && portEntry.second["type"]
                                && portEntry.second["type"].IsScalar()) {
                                QString portType = QString::fromStdString(
                                    portEntry.second["type"].as<std::string>());
                                if (portType != "logic" && portType != "wire") {
                                    /* Extract width from type like "logic[7:0]" */
                                    QRegularExpression widthRegex(R"(\[\s*(\d+)\s*:\s*(\d+)\s*\])");
                                    QRegularExpressionMatch match = widthRegex.match(portType);
                                    if (match.hasMatch()) {
                                        int msb  = match.captured(1).toInt();
                                        int lsb  = match.captured(2).toInt();
                                        regWidth = QString("[%1:%2] ").arg(msb).arg(lsb);
                                    }
                                }
                                break;
                            }
                        }
                    }
                }
                out << "    reg " << regWidth << outputSignal << "_reg;\n";
            }
            out << "\n    /* Assign internal regs to outputs */\n";
            for (const QString &outputSignal : alwaysBlockOutputs) {
                out << "    assign " << outputSignal << " = " << outputSignal << "_reg;\n";
            }
        }

        out << "\n    /* Combinational logic */\n";

        for (size_t i = 0; i < netlistData["comb"].size(); ++i) {
            const YAML::Node &combItem = netlistData["comb"][i];

            if (!combItem.IsMap() || !combItem["out"] || !combItem["out"].IsScalar()) {
                continue; /* Skip invalid items */
            }

            const QString outputSignal = QString::fromStdString(combItem["out"].as<std::string>());

            if (combItem["expr"] && combItem["expr"].IsScalar()) {
                /* Generate assign statement */
                const QString expression = QString::fromStdString(
                    combItem["expr"].as<std::string>());
                out << "    assign " << outputSignal << " = " << expression << ";\n";
            } else if (combItem["if"] && combItem["if"].IsSequence()) {
                /* Generate always block with if-else logic */
                const QString regSignal = outputSignal + "_reg";
                out << "    always @(*) begin\n";

                /* Set default value if specified */
                if (combItem["default"] && combItem["default"].IsScalar()) {
                    const QString defaultValue = QString::fromStdString(
                        combItem["default"].as<std::string>());
                    out << "        " << regSignal << " = " << defaultValue << ";\n";
                }

                /* Generate if-else chain */
                bool firstIf = true;
                for (const auto &ifCondition : combItem["if"]) {
                    if (!ifCondition.IsMap() || !ifCondition["cond"] || !ifCondition["then"]) {
                        continue; /* Skip invalid conditions */
                    }

                    const QString condition = QString::fromStdString(
                        ifCondition["cond"].as<std::string>());

                    if (firstIf) {
                        out << "        if (" << condition << ") begin\n";
                        firstIf = false;
                    } else {
                        out << "        else if (" << condition << ") begin\n";
                    }

                    /* Generate nested value (could be simple or nested case) */
                    QString nestedCode = generateNestedCombValue(ifCondition["then"], regSignal, 3);
                    out << nestedCode;
                    out << "        end\n";
                }

                out << "    end\n";
            } else if (
                combItem["case"] && combItem["case"].IsScalar() && combItem["cases"]
                && combItem["cases"].IsMap()) {
                /* Generate always block with case statement */
                const QString regSignal = outputSignal + "_reg";
                out << "    always @(*) begin\n";

                /* Set default value if specified */
                if (combItem["default"] && combItem["default"].IsScalar()) {
                    const QString defaultValue = QString::fromStdString(
                        combItem["default"].as<std::string>());
                    out << "        " << regSignal << " = " << defaultValue << ";\n";
                }

                const QString caseExpression = QString::fromStdString(
                    combItem["case"].as<std::string>());
                out << "        case (" << caseExpression << ")\n";

                /* Generate case entries */
                for (const auto &caseEntry : combItem["cases"]) {
                    if (!caseEntry.first.IsScalar() || !caseEntry.second.IsScalar()) {
                        continue; /* Skip invalid entries */
                    }

                    const QString caseValue = QString::fromStdString(
                        caseEntry.first.as<std::string>());
                    const QString resultValue = QString::fromStdString(
                        caseEntry.second.as<std::string>());
                    out << "            " << caseValue << ": " << regSignal << " = " << resultValue
                        << ";\n";
                }

                /* Add default case if specified */
                if (combItem["default"] && combItem["default"].IsScalar()) {
                    const QString defaultValue = QString::fromStdString(
                        combItem["default"].as<std::string>());
                    out << "            default: " << regSignal << " = " << defaultValue << ";\n";
                }

                out << "        endcase\n";
                out << "    end\n";
            }

            /* Add blank line between different combinational logic blocks */
            if (i < netlistData["comb"].size() - 1) {
                out << "\n";
            }
        }
    }

    /* Generate sequential logic after combinational logic */
    if (netlistData["seq"] && netlistData["seq"].IsSequence() && netlistData["seq"].size() > 0) {
        /* First pass: collect all outputs that need internal reg declarations */
        QSet<QString> seqRegOutputs;
        for (size_t i = 0; i < netlistData["seq"].size(); ++i) {
            const YAML::Node &seqItem = netlistData["seq"][i];
            if (!seqItem.IsMap() || !seqItem["reg"] || !seqItem["reg"].IsScalar()) {
                continue;
            }
            const QString regName = QString::fromStdString(seqItem["reg"].as<std::string>());
            seqRegOutputs.insert(regName);
        }

        /* Generate internal reg declarations for sequential outputs */
        if (!seqRegOutputs.isEmpty()) {
            out << "\n    /* Internal reg declarations for sequential logic */\n";
            for (const QString &regName : seqRegOutputs) {
                /* Find the port width for this output signal */
                QString regWidth = "";
                if (netlistData["port"] && netlistData["port"].IsMap()) {
                    for (const auto &portEntry : netlistData["port"]) {
                        if (portEntry.first.IsScalar()
                            && QString::fromStdString(portEntry.first.as<std::string>())
                                   == regName) {
                            if (portEntry.second.IsMap() && portEntry.second["type"]
                                && portEntry.second["type"].IsScalar()) {
                                QString portType = QString::fromStdString(
                                    portEntry.second["type"].as<std::string>());
                                if (portType != "logic" && portType != "wire") {
                                    /* Extract width from type like "logic[7:0]" */
                                    QRegularExpression widthRegex(R"(\[\s*(\d+)\s*:\s*(\d+)\s*\])");
                                    QRegularExpressionMatch match = widthRegex.match(portType);
                                    if (match.hasMatch()) {
                                        int msb  = match.captured(1).toInt();
                                        int lsb  = match.captured(2).toInt();
                                        regWidth = QString("[%1:%2] ").arg(msb).arg(lsb);
                                    }
                                }
                                break;
                            }
                        }
                    }
                }
                out << "    reg " << regWidth << regName << "_reg;\n";
            }
            out << "\n    /* Assign internal regs to outputs */\n";
            for (const QString &regName : seqRegOutputs) {
                out << "    assign " << regName << " = " << regName << "_reg;\n";
            }
        }

        out << "\n    /* Sequential logic */\n";

        for (size_t i = 0; i < netlistData["seq"].size(); ++i) {
            const YAML::Node &seqItem = netlistData["seq"][i];

            if (!seqItem.IsMap() || !seqItem["reg"] || !seqItem["clk"] || !seqItem["reg"].IsScalar()
                || !seqItem["clk"].IsScalar()) {
                continue; /* Skip invalid items */
            }

            const QString regName   = QString::fromStdString(seqItem["reg"].as<std::string>());
            const QString regSignal = regName + "_reg";
            const QString clkSignal = QString::fromStdString(seqItem["clk"].as<std::string>());

            /* Get edge type (default to posedge) */
            QString edgeType = "posedge";
            if (seqItem["edge"] && seqItem["edge"].IsScalar()) {
                const QString edge = QString::fromStdString(seqItem["edge"].as<std::string>());
                if (edge == "neg") {
                    edgeType = "negedge";
                }
            }

            /* Generate always block */
            out << "    always @(" << edgeType << " " << clkSignal;

            /* Add reset signal to sensitivity list if present */
            if (seqItem["rst"] && seqItem["rst"].IsScalar()) {
                const QString rstSignal = QString::fromStdString(seqItem["rst"].as<std::string>());
                /* Assume asynchronous reset for now */
                out << " or negedge " << rstSignal;
            }

            out << ") begin\n";

            /* Handle reset logic if present */
            if (seqItem["rst"] && seqItem["rst_val"] && seqItem["rst_val"].IsScalar()) {
                const QString rstSignal = QString::fromStdString(seqItem["rst"].as<std::string>());
                const QString rstValue  = QString::fromStdString(
                    seqItem["rst_val"].as<std::string>());

                out << "        if (!" << rstSignal << ") begin\n";
                out << "            " << regSignal << " <= " << rstValue << ";\n";
                out << "        end else begin\n";

                /* Generate main logic with additional indentation */
                generateSeqLogicContent(seqItem, regSignal, out, 3);

                out << "        end\n";
            } else {
                /* Generate main logic without reset */
                generateSeqLogicContent(seqItem, regSignal, out, 2);
            }

            out << "    end\n";

            /* Add blank line between different sequential logic blocks */
            if (i < netlistData["seq"].size() - 1) {
                out << "\n";
            }
        }
    }

    /* Generate FSM logic after sequential logic */
    if (netlistData["fsm"] && netlistData["fsm"].IsSequence() && netlistData["fsm"].size() > 0) {
        out << "\n    /* Finite State Machine logic */\n";

        for (size_t i = 0; i < netlistData["fsm"].size(); ++i) {
            const YAML::Node &fsmItem = netlistData["fsm"][i];

            if (!fsmItem.IsMap() || !fsmItem["name"] || !fsmItem["name"].IsScalar()
                || !fsmItem["clk"] || !fsmItem["clk"].IsScalar() || !fsmItem["rst"]
                || !fsmItem["rst"].IsScalar() || !fsmItem["rst_state"]
                || !fsmItem["rst_state"].IsScalar()) {
                qWarning() << "Warning: FSM" << i << "has invalid format, skipping";
                continue; /* Skip invalid FSM items */
            }

            generateFSMVerilog(fsmItem, out);

            /* Add blank line between different FSM blocks */
            if (i < netlistData["fsm"].size() - 1) {
                out << "\n";
            }
        }
    }

    /* Close module */
    out << "\nendmodule\n";

    outputFile.close();
    qInfo() << "Successfully generated Verilog file:" << outputFilePath;

    /* Format generated Verilog file if verible-verilog-format is available */
    formatVerilogFile(outputFilePath);

    return true;
}

bool QSocGenerateManager::formatVerilogFile(const QString &filePath)
{
    /* Check if verible-verilog-format tool is available in the system */
    QProcess which;
    which.start("which", QStringList() << "verible-verilog-format");
    which.waitForFinished();

    if (which.exitCode() != 0) {
        /* Tool not found, silently return */
        qDebug() << "verible-verilog-format not found, skipping formatting";
        return false;
    }

    /* Tool found, proceed with formatting */
    qInfo() << "Formatting Verilog file using verible-verilog-format...";

    QProcess formatter;
    /* clang-format off */
    const QString argsStr = QStaticStringWeaver::stripCommonLeadingWhitespace(R"(
        --inplace
        --column_limit 119
        --indentation_spaces 4
        --line_break_penalty 4
        --wrap_spaces 4
        --port_declarations_alignment align
        --port_declarations_indentation indent
        --formal_parameters_alignment align
        --formal_parameters_indentation indent
        --assignment_statement_alignment align
        --enum_assignment_statement_alignment align
        --class_member_variable_alignment align
        --module_net_variable_alignment align
        --named_parameter_alignment align
        --named_parameter_indentation indent
        --named_port_alignment align
        --named_port_indentation indent
        --struct_union_members_alignment align
    )");
    /* clang-format on */

    QStringList args = argsStr.split(QRegularExpression("\\s+"), Qt::SkipEmptyParts);
    args << filePath;

    formatter.start("verible-verilog-format", args);
    formatter.waitForFinished();

    if (formatter.exitCode() == 0) {
        qInfo() << "Successfully formatted Verilog file";
        return true;
    }
    qWarning() << "Error formatting Verilog file:" << formatter.errorString();
    return false;
}

QSocNumberInfo QSocGenerateManager::parseNumber(const QString &numStr)
{
    QSocNumberInfo result;
    result.originalString   = numStr;
    result.base             = QSocNumberInfo::Base::Unknown;
    result.value            = 0;
    result.width            = 0;
    result.hasExplicitWidth = false;
    result.errorDetected    = false;

    /* Remove all underscores from the string (Verilog style) */
    QString cleanStr = numStr;
    cleanStr.remove('_');

    if (cleanStr.isEmpty()) {
        qWarning() << "Empty number string";
        return result;
    }

    /* Check for Verilog-style format with vector range: [31:0] */
    const QRegularExpression      vectorWidthRegex(R"(\[(\d+)\s*:\s*(\d+)\])");
    const QRegularExpressionMatch vectorWidthMatch = vectorWidthRegex.match(cleanStr);

    if (vectorWidthMatch.hasMatch()) {
        bool      msb_ok = false;
        bool      lsb_ok = false;
        const int msb    = vectorWidthMatch.captured(1).toInt(&msb_ok);
        const int lsb    = vectorWidthMatch.captured(2).toInt(&lsb_ok);

        if (msb_ok && lsb_ok) {
            result.width            = msb - lsb + 1;
            result.hasExplicitWidth = true;

            /* Remove the vector range from the string for further processing */
            cleanStr.remove(vectorWidthRegex);
        }
    }

    /* Check for Verilog-style format: <width>'<base><value> */
    const QRegularExpression      verilogNumberRegex(R"((\d+)'([bdohxBDOHX])([0-9a-fA-F]+))");
    const QRegularExpressionMatch verilogMatch = verilogNumberRegex.match(cleanStr);

    if (verilogMatch.hasMatch()) {
        /* Extract width, base, and value from the Verilog format */
        bool      widthOk = false;
        const int width   = verilogMatch.captured(1).toInt(&widthOk);

        if (widthOk && !result.hasExplicitWidth) {
            result.width            = width;
            result.hasExplicitWidth = true;
        }

        const QChar   baseChar = verilogMatch.captured(2).at(0).toLower();
        const QString valueStr = verilogMatch.captured(3);

        /* Determine the base from the base character */
        switch (baseChar.toLatin1()) {
        case 'b': /* Binary */
            result.base = QSocNumberInfo::Base::Binary;
            try {
                result.value = QSocNumberInfo::stringToBigIntegerWithBase(valueStr.toStdString(), 2);
            } catch (const std::exception &e) {
                result.errorDetected = true;
                qWarning() << "Binary value error, using original string:" << numStr
                           << "Error:" << e.what();
            }
            break;
        case 'o': /* Octal */
            result.base = QSocNumberInfo::Base::Octal;
            try {
                result.value = QSocNumberInfo::stringToBigIntegerWithBase(valueStr.toStdString(), 8);
            } catch (const std::exception &e) {
                result.errorDetected = true;
                qWarning() << "Octal value error, using original string:" << numStr
                           << "Error:" << e.what();
            }
            break;
        case 'd': /* Decimal */
            result.base = QSocNumberInfo::Base::Decimal;
            try {
                result.value
                    = QSocNumberInfo::stringToBigIntegerWithBase(valueStr.toStdString(), 10);
            } catch (const std::exception &e) {
                result.errorDetected = true;
                qWarning() << "Decimal value error, using original string:" << numStr
                           << "Error:" << e.what();
            }
            break;
        case 'h': /* Hexadecimal */
        case 'x': /* Alternative for Hexadecimal */
            result.base = QSocNumberInfo::Base::Hexadecimal;
            try {
                result.value
                    = QSocNumberInfo::stringToBigIntegerWithBase(valueStr.toStdString(), 16);
            } catch (const std::exception &e) {
                result.errorDetected = true;
                qWarning() << "Hexadecimal value error, using original string:" << numStr
                           << "Error:" << e.what();
            }
            break;
        default:
            qWarning() << "Unknown base character in Verilog number:" << baseChar;
        }
    } else {
        /* Handle standalone Verilog-style base prefixes (without width): 'b, 'h, 'o, 'd */
        const QRegularExpression      verilogBaseRegex(R"('([bdohxBDOHX])([0-9a-fA-F]+))");
        const QRegularExpressionMatch verilogBaseMatch = verilogBaseRegex.match(cleanStr);

        if (verilogBaseMatch.hasMatch()) {
            const QChar   baseChar = verilogBaseMatch.captured(1).at(0).toLower();
            const QString valueStr = verilogBaseMatch.captured(2);

            /* Determine the base from the base character */
            switch (baseChar.toLatin1()) {
            case 'b': /* Binary */
                result.base = QSocNumberInfo::Base::Binary;
                try {
                    result.value
                        = QSocNumberInfo::stringToBigIntegerWithBase(valueStr.toStdString(), 2);
                } catch (const std::exception &e) {
                    result.errorDetected = true;
                    qWarning() << "Binary value error, using original string:" << numStr
                               << "Error:" << e.what();
                }
                break;
            case 'o': /* Octal */
                result.base = QSocNumberInfo::Base::Octal;
                try {
                    result.value
                        = QSocNumberInfo::stringToBigIntegerWithBase(valueStr.toStdString(), 8);
                } catch (const std::exception &e) {
                    result.errorDetected = true;
                    qWarning() << "Octal value error, using original string:" << numStr
                               << "Error:" << e.what();
                }
                break;
            case 'd': /* Decimal */
                result.base = QSocNumberInfo::Base::Decimal;
                try {
                    result.value
                        = QSocNumberInfo::stringToBigIntegerWithBase(valueStr.toStdString(), 10);
                } catch (const std::exception &e) {
                    result.errorDetected = true;
                    qWarning() << "Decimal value error, using original string:" << numStr
                               << "Error:" << e.what();
                }
                break;
            case 'h': /* Hexadecimal */
            case 'x': /* Alternative for Hexadecimal */
                result.base = QSocNumberInfo::Base::Hexadecimal;
                try {
                    result.value
                        = QSocNumberInfo::stringToBigIntegerWithBase(valueStr.toStdString(), 16);
                } catch (const std::exception &e) {
                    result.errorDetected = true;
                    qWarning() << "Hexadecimal value error, using original string:" << numStr
                               << "Error:" << e.what();
                }
                break;
            default:
                qWarning() << "Unknown base character in Verilog number:" << baseChar;
            }
        } else {
            /* Try C-style format */
            if (cleanStr.startsWith("0x") || cleanStr.startsWith("0X")) {
                /* Hexadecimal */
                result.base = QSocNumberInfo::Base::Hexadecimal;
                try {
                    result.value = QSocNumberInfo::stringToBigIntegerWithBase(
                        cleanStr.mid(2).toStdString(), 16);
                } catch (const std::exception &e) {
                    result.errorDetected = true;
                    qWarning() << "Hexadecimal value error, using original string:" << numStr
                               << "Error:" << e.what();
                }
            } else if (cleanStr.startsWith("0b") || cleanStr.startsWith("0B")) {
                /* Binary (C++14 style) */
                result.base = QSocNumberInfo::Base::Binary;
                try {
                    result.value = QSocNumberInfo::stringToBigIntegerWithBase(
                        cleanStr.mid(2).toStdString(), 2);
                } catch (const std::exception &e) {
                    result.errorDetected = true;
                    qWarning() << "Binary value error, using original string:" << numStr
                               << "Error:" << e.what();
                }
            } else if (cleanStr.startsWith("0") && cleanStr.length() > 1) {
                /* Octal */
                result.base = QSocNumberInfo::Base::Octal;
                try {
                    result.value
                        = QSocNumberInfo::stringToBigIntegerWithBase(cleanStr.toStdString(), 8);
                } catch (const std::exception &e) {
                    result.errorDetected = true;
                    qWarning() << "Octal value error, using original string:" << numStr
                               << "Error:" << e.what();
                }
            } else {
                /* Decimal */
                result.base = QSocNumberInfo::Base::Decimal;
                try {
                    result.value
                        = QSocNumberInfo::stringToBigIntegerWithBase(cleanStr.toStdString(), 10);
                } catch (const std::exception &e) {
                    result.errorDetected = true;
                    qWarning() << "Failed to parse decimal number, using original string:"
                               << cleanStr << "Error:" << e.what();
                }
            }
        }
    }

    /* Calculate width if not explicitly provided */
    if (!result.hasExplicitWidth) {
        if (result.errorDetected) {
            /* For error values, set a reasonable width based on the original string */
            if (result.originalString.toLower().contains('h')) {
                /* Hex values: each digit is 4 bits */
                const int digits = static_cast<int>(result.originalString.length());
                /* Rough estimate, removing prefix parts */
                result.width = (digits - 3) * 4; /* Assuming format like "N'h..." */
            } else if (result.originalString.toLower().contains('b')) {
                /* Binary values: each digit is 1 bit */
                const int digits = static_cast<int>(result.originalString.length());
                /* Rough estimate, removing prefix parts */
                result.width = digits - 3; /* Assuming format like "N'b..." */
            } else if (result.originalString.toLower().contains('o')) {
                /* Octal values: each digit is 3 bits */
                const int digits = static_cast<int>(result.originalString.length());
                /* Rough estimate, removing prefix parts */
                result.width = (digits - 3) * 3; /* Assuming format like "N'o..." */
            } else {
                /* Decimal values */
                if (result.originalString.length() > 20) {
                    result.width = 128; /* Very large numbers */
                } else if (result.originalString.length() > 10) {
                    result.width = 64; /* Medium large numbers */
                } else {
                    result.width = 32; /* Regular numbers */
                }
            }
        } else if (result.value == 0) {
            result.width = 1; /* Special case for zero */
        } else {
            /* Calculate minimum required width based on the value */
            BigInteger tempValue       = result.value;
            int        calculatedWidth = 0;

            /* Count how many bits are needed */
            while (tempValue != 0) {
                /* Shift right by one bit */
                if (tempValue.getSign() == BigInteger::negative) {
                    BigUnsigned magnitude = tempValue.getMagnitude();
                    magnitude             = magnitude >> 1;
                    tempValue             = BigInteger(magnitude, BigInteger::negative);
                } else {
                    BigUnsigned magnitude = tempValue.getMagnitude();
                    magnitude             = magnitude >> 1;
                    tempValue             = BigInteger(magnitude);
                }
                calculatedWidth++;
            }

            /* Use exact calculated width */
            result.width = calculatedWidth;
        }
    }

    /* Add debug output */
    qDebug() << "Parsed number:" << numStr << "Value:"
             << QString::fromStdString(QSocNumberInfo::bigIntegerToStringWithBase(result.value, 10))
             << "Base:" << static_cast<int>(result.base) << "Width:" << result.width
             << (result.hasExplicitWidth ? "(explicit)" : "(calculated)")
             << (result.errorDetected ? " (error detected)" : "");

    return result;
}

/**
 * @brief Generate nested combinational logic value (for if/case nesting)
 * @param valueNode The YAML node containing the value (scalar or nested structure)
 * @param outputSignal The output signal name
 * @param indentLevel The indentation level for proper formatting
 * @return Generated Verilog code string
 */
QString QSocGenerateManager::generateNestedCombValue(
    const YAML::Node &valueNode, const QString &outputSignal, int indentLevel)
{
    QString result;
    QString indent = QString("    ").repeated(indentLevel); /* 4 spaces per indent level */

    if (valueNode.IsScalar()) {
        /* Simple scalar value */
        const QString value = QString::fromStdString(valueNode.as<std::string>());
        result += QString("%1%2 = %3;\n").arg(indent).arg(outputSignal).arg(value);
    } else if (valueNode.IsMap() && valueNode["case"]) {
        /* Nested case statement */
        const QString caseExpression = QString::fromStdString(valueNode["case"].as<std::string>());
        result += QString("%1case (%2)\n").arg(indent).arg(caseExpression);

        /* Generate case entries */
        if (valueNode["cases"] && valueNode["cases"].IsMap()) {
            for (const auto &caseEntry : valueNode["cases"]) {
                if (!caseEntry.first.IsScalar() || !caseEntry.second.IsScalar()) {
                    continue; /* Skip invalid entries */
                }

                const QString caseValue = QString::fromStdString(caseEntry.first.as<std::string>());
                const QString resultValue = QString::fromStdString(
                    caseEntry.second.as<std::string>());
                result += QString("%1    %2: %3 = %4;\n")
                              .arg(indent)
                              .arg(caseValue)
                              .arg(outputSignal)
                              .arg(resultValue);
            }
        }

        /* Add default case if specified */
        if (valueNode["default"] && valueNode["default"].IsScalar()) {
            const QString defaultValue = QString::fromStdString(
                valueNode["default"].as<std::string>());
            result += QString("%1    default: %2 = %3;\n")
                          .arg(indent)
                          .arg(outputSignal)
                          .arg(defaultValue);
        }

        result += QString("%1endcase\n").arg(indent);
    } else {
        /* Unsupported nested structure - fallback to comment */
        result += QString("%1/* FIXME: Unsupported nested structure for %2 */\n")
                      .arg(indent)
                      .arg(outputSignal);
    }

    return result;
}

/**
 * @brief Generate nested sequential logic value (for if/case nesting)
 * @param valueNode The YAML node containing the value (scalar or nested structure)
 * @param regName The register name
 * @param indentLevel The indentation level for proper formatting
 * @return Generated Verilog code string
 */
QString QSocGenerateManager::generateNestedSeqValue(
    const YAML::Node &valueNode, const QString &regName, int indentLevel)
{
    QString result;
    QString indent = QString("    ").repeated(indentLevel); /* 4 spaces per indent level */

    if (valueNode.IsScalar()) {
        /* Simple scalar value */
        const QString value = QString::fromStdString(valueNode.as<std::string>());
        result += QString("%1%2 <= %3;\n").arg(indent).arg(regName).arg(value);
    } else if (valueNode.IsMap() && valueNode["case"]) {
        /* Nested case statement */
        const QString caseExpression = QString::fromStdString(valueNode["case"].as<std::string>());
        result += QString("%1case (%2)\n").arg(indent).arg(caseExpression);

        /* Generate case entries */
        if (valueNode["cases"] && valueNode["cases"].IsMap()) {
            for (const auto &caseEntry : valueNode["cases"]) {
                if (!caseEntry.first.IsScalar() || !caseEntry.second.IsScalar()) {
                    continue; /* Skip invalid entries */
                }

                const QString caseValue = QString::fromStdString(caseEntry.first.as<std::string>());
                const QString resultValue = QString::fromStdString(
                    caseEntry.second.as<std::string>());
                result += QString("%1    %2: %3 <= %4;\n")
                              .arg(indent)
                              .arg(caseValue)
                              .arg(regName)
                              .arg(resultValue);
            }
        }

        /* Add default case if specified */
        if (valueNode["default"] && valueNode["default"].IsScalar()) {
            const QString defaultValue = QString::fromStdString(
                valueNode["default"].as<std::string>());
            result
                += QString("%1    default: %2 <= %3;\n").arg(indent).arg(regName).arg(defaultValue);
        }

        result += QString("%1endcase\n").arg(indent);
    } else {
        /* Unsupported nested structure - fallback to comment */
        result += QString("%1/* FIXME: Unsupported nested structure for %2 */\n")
                      .arg(indent)
                      .arg(regName);
    }

    return result;
}

/**
 * @brief Generate sequential logic content for a register
 * @param seqItem The YAML node containing the sequential logic specification
 * @param regName The register name
 * @param out Output text stream
 * @param indentLevel The indentation level for proper formatting
 */
void QSocGenerateManager::generateSeqLogicContent(
    const YAML::Node &seqItem, const QString &regName, QTextStream &out, int indentLevel)
{
    QString indent = QString("    ").repeated(indentLevel); /* 4 spaces per indent level */

    /* Check for enable signal */
    if (seqItem["enable"] && seqItem["enable"].IsScalar()) {
        const QString enableSignal = QString::fromStdString(seqItem["enable"].as<std::string>());
        out << indent << "if (" << enableSignal << ") begin\n";
        /* Increase indentation for enabled logic */
        indent += "    ";
    }

    /* Generate logic based on type */
    if (seqItem["next"] && seqItem["next"].IsScalar()) {
        /* Simple next-state assignment */
        const QString nextValue = QString::fromStdString(seqItem["next"].as<std::string>());
        out << indent << regName << " <= " << nextValue << ";\n";
    } else if (seqItem["if"] && seqItem["if"].IsSequence()) {
        /* Conditional logic using if-else chain */

        /* Set default value if specified */
        if (seqItem["default"] && seqItem["default"].IsScalar()) {
            const QString defaultValue = QString::fromStdString(
                seqItem["default"].as<std::string>());
            out << indent << regName << " <= " << defaultValue << ";\n";
        }

        /* Generate if-else chain */
        bool firstIf = true;
        for (const auto &ifCondition : seqItem["if"]) {
            if (!ifCondition.IsMap() || !ifCondition["cond"] || !ifCondition["then"]
                || !ifCondition["cond"].IsScalar()) {
                continue; /* Skip invalid conditions */
            }

            const QString condition = QString::fromStdString(ifCondition["cond"].as<std::string>());

            if (firstIf) {
                out << indent << "if (" << condition << ") begin\n";
                firstIf = false;
            } else {
                out << indent << "else if (" << condition << ") begin\n";
            }

            /* Handle both scalar and nested 'then' values */
            if (ifCondition["then"].IsScalar()) {
                /* Simple scalar assignment */
                const QString thenValue = QString::fromStdString(
                    ifCondition["then"].as<std::string>());
                out << indent << "    " << regName << " <= " << thenValue << ";\n";
            } else if (ifCondition["then"].IsMap()) {
                /* Nested structure - use helper function */
                QString nestedCode
                    = generateNestedSeqValue(ifCondition["then"], regName, indentLevel + 1);
                out << nestedCode;
            }

            out << indent << "end\n";
        }
    }

    /* Close enable block if present */
    if (seqItem["enable"] && seqItem["enable"].IsScalar()) {
        /* Remove the extra indentation */
        indent = QString("    ").repeated(indentLevel);
        out << indent << "end\n";
    }
}

/**
 * @brief Generate FSM Verilog code for a single FSM
 * @param fsmItem The YAML node containing the FSM specification
 * @param out Output text stream
 */
void QSocGenerateManager::generateFSMVerilog(const YAML::Node &fsmItem, QTextStream &out)
{
    const QString fsmName   = QString::fromStdString(fsmItem["name"].as<std::string>());
    const QString clkSignal = QString::fromStdString(fsmItem["clk"].as<std::string>());
    const QString rstSignal = QString::fromStdString(fsmItem["rst"].as<std::string>());
    const QString rstState  = QString::fromStdString(fsmItem["rst_state"].as<std::string>());

    /* Get encoding type (default to binary) */
    QString encoding = "bin";
    if (fsmItem["encoding"] && fsmItem["encoding"].IsScalar()) {
        encoding = QString::fromStdString(fsmItem["encoding"].as<std::string>());
    }

    /* Check if this is microcode mode */
    bool isMicrocodeMode = fsmItem["fields"] && fsmItem["fields"].IsMap();

    if (isMicrocodeMode) {
        generateMicrocodeFSM(fsmItem, out);
    } else {
        generateTableFSM(fsmItem, out);
    }
}

/**
 * @brief Generate Table-mode FSM Verilog code
 * @param fsmItem The YAML node containing the FSM specification
 * @param out Output text stream
 */
QString QSocGenerateManager::formatConditionForVerilog(const QString &condition)
{
    QString formatted = condition;

    /* Replace simple numeric values with proper Verilog format */
    QRegularExpression              simpleNumRegex("\\b(\\d+)\\b");
    QRegularExpressionMatchIterator it = simpleNumRegex.globalMatch(formatted);
    QStringList                     matches;
    while (it.hasNext()) {
        QRegularExpressionMatch match = it.next();
        matches.append(match.captured(1));
    }

    /* Replace from right to left to preserve positions */
    for (int i = matches.size() - 1; i >= 0; i--) {
        QString num = matches[i];
        QString replacement;
        if (num == "0") {
            replacement = "1'b0";
        } else if (num == "1") {
            replacement = "1'b1";
        } else {
            /* For multi-bit numbers, try to determine width from context */
            int value = num.toInt();
            int width = 1;
            while ((1 << width) <= value) {
                width++;
            }
            replacement = QString("%1'd%2").arg(width).arg(num);
        }
        formatted.replace(QRegularExpression("\\b" + num + "\\b"), replacement);
    }

    return formatted;
}

void QSocGenerateManager::generateTableFSM(const YAML::Node &fsmItem, QTextStream &out)
{
    const QString fsmName      = QString::fromStdString(fsmItem["name"].as<std::string>());
    const QString fsmNameUpper = fsmName.toUpper();
    const QString fsmNameLower = fsmName.toLower();
    const QString clkSignal    = QString::fromStdString(fsmItem["clk"].as<std::string>());
    const QString rstSignal    = QString::fromStdString(fsmItem["rst"].as<std::string>());
    const QString rstState     = QString::fromStdString(fsmItem["rst_state"].as<std::string>());

    /* Get encoding type (default to binary) */
    QString encoding = "bin";
    if (fsmItem["encoding"] && fsmItem["encoding"].IsScalar()) {
        encoding = QString::fromStdString(fsmItem["encoding"].as<std::string>());
    }

    /* Collect all states from trans section */
    QStringList allStates;
    if (fsmItem["trans"] && fsmItem["trans"].IsMap()) {
        for (const auto &transEntry : fsmItem["trans"]) {
            if (transEntry.first.IsScalar()) {
                const QString stateName = QString::fromStdString(transEntry.first.as<std::string>());
                if (!allStates.contains(stateName)) {
                    allStates.append(stateName);
                }
            }
        }
    }

    /* Also collect states from moore section */
    if (fsmItem["moore"] && fsmItem["moore"].IsMap()) {
        for (const auto &mooreEntry : fsmItem["moore"]) {
            if (mooreEntry.first.IsScalar()) {
                const QString stateName = QString::fromStdString(mooreEntry.first.as<std::string>());
                if (!allStates.contains(stateName)) {
                    allStates.append(stateName);
                }
            }
        }
    }

    /* Generate state typedef */
    out << "\n    /* " << fsmName << " : Table FSM generated by YAML-DSL */\n";

    /* Calculate state width */
    int stateWidth = 1;
    int numStates  = allStates.size();
    if (encoding == "onehot") {
        stateWidth = numStates;
    } else {
        while ((1 << stateWidth) < numStates) {
            stateWidth++;
        }
    }

    /* Skip typedef enum for Verilog 2005 compatibility - will use localparam instead */

    /* Generate state registers */
    out << "    /* " << fsmName << " state registers */\n";
    out << "    reg [" << (stateWidth - 1) << ":0] " << fsmNameLower << "_cur_state, "
        << fsmNameLower << "_nxt_state;\n\n";

    /* Generate state parameter definitions for Verilog 2005 compatibility */
    for (int i = 0; i < allStates.size(); ++i) {
        QString stateValue;
        if (encoding == "onehot") {
            stateValue = QString("%1'd%2").arg(stateWidth).arg(1 << i);
        } else if (encoding == "gray") {
            int grayValue = i ^ (i >> 1);
            stateValue    = QString("%1'd%2").arg(stateWidth).arg(grayValue);
        } else {
            stateValue = QString("%1'd%2").arg(stateWidth).arg(i);
        }
        out << "    localparam " << fsmNameUpper << "_" << allStates[i] << " = " << stateValue
            << ";\n";
    }
    out << "\n";

    /* Generate next state logic */
    out << "    /* " << fsmName << " next-state logic */\n";
    out << "    always @(*) begin\n";
    out << "        " << fsmNameLower << "_nxt_state = " << fsmNameLower << "_cur_state;\n";
    out << "        case (" << fsmNameLower << "_cur_state)\n";

    /* Generate transitions */
    if (fsmItem["trans"] && fsmItem["trans"].IsMap()) {
        for (const auto &transEntry : fsmItem["trans"]) {
            if (!transEntry.first.IsScalar() || !transEntry.second.IsSequence()) {
                continue;
            }

            const QString stateName = QString::fromStdString(transEntry.first.as<std::string>());
            out << "            " << fsmNameUpper << "_" << stateName << ":";

            /* Check if multiple transitions exist for this state */
            bool hasMultipleTransitions = transEntry.second.size() > 1;
            if (hasMultipleTransitions) {
                out << "\n                begin\n";
            }

            /* Process each transition condition */
            for (const auto &transition : transEntry.second) {
                if (!transition.IsMap() || !transition["cond"] || !transition["next"]) {
                    continue;
                }

                const QString condition = QString::fromStdString(
                    transition["cond"].as<std::string>());
                const QString nextState = QString::fromStdString(
                    transition["next"].as<std::string>());

                QString indent = hasMultipleTransitions ? "                    "
                                                        : "\n                ";
                if (condition == "1") {
                    out << indent << "if (1'b1) " << fsmNameLower << "_nxt_state = " << fsmNameUpper
                        << "_" << nextState << ";\n";
                } else {
                    QString formattedCondition = formatConditionForVerilog(condition);
                    out << indent << "if (" << formattedCondition << ") " << fsmNameLower
                        << "_nxt_state = " << fsmNameUpper << "_" << nextState << ";\n";
                }
            }

            if (hasMultipleTransitions) {
                out << "                end\n";
            }
        }
    }

    out << "            default: " << fsmNameLower << "_nxt_state = " << fsmNameLower
        << "_cur_state;\n";
    out << "        endcase\n";
    out << "    end\n\n";

    /* Generate state register */
    out << "    /* " << fsmName << " state register w/ async reset */\n";
    out << "    always @(posedge " << clkSignal << " or negedge " << rstSignal << ")\n";
    out << "        if (!" << rstSignal << ") " << fsmNameLower << "_cur_state <= " << fsmNameUpper
        << "_" << rstState << ";\n";
    out << "        else        " << fsmNameLower << "_cur_state <= " << fsmNameLower
        << "_nxt_state;\n\n";

    /* Generate Moore outputs */
    if (fsmItem["moore"] && fsmItem["moore"].IsMap()) {
        out << "    /* " << fsmName << " Moore outputs */\n";

        /* Collect all unique output signals */
        QSet<QString> allOutputs;
        for (const auto &mooreEntry : fsmItem["moore"]) {
            if (mooreEntry.second.IsMap()) {
                for (const auto &output : mooreEntry.second) {
                    if (output.first.IsScalar()) {
                        allOutputs.insert(QString::fromStdString(output.first.as<std::string>()));
                    }
                }
            }
        }

        /* Generate internal reg signals for Moore outputs (Verilog 2005 compatibility) */
        for (const QString &output : allOutputs) {
            out << "    reg " << fsmNameLower << "_" << output << "_reg;\n";
        }
        out << "\n";

        /* Generate assigns from internal regs to output ports */
        for (const QString &output : allOutputs) {
            out << "    assign " << output << " = " << fsmNameLower << "_" << output << "_reg;\n";
        }
        out << "\n";

        /* Generate always block with default values */
        out << "    always @(*) begin\n";
        for (const QString &output : allOutputs) {
            out << "        " << fsmNameLower << "_" << output << "_reg = 1'b0;\n";
        }

        out << "        case (" << fsmNameLower << "_cur_state)\n";
        for (const auto &mooreEntry : fsmItem["moore"]) {
            if (!mooreEntry.first.IsScalar() || !mooreEntry.second.IsMap()) {
                continue;
            }

            const QString stateName = QString::fromStdString(mooreEntry.first.as<std::string>());
            out << "            " << fsmNameUpper << "_" << stateName << ":\n";
            out << "                begin\n";

            for (const auto &output : mooreEntry.second) {
                if (output.first.IsScalar() && output.second.IsScalar()) {
                    const QString outputName = QString::fromStdString(
                        output.first.as<std::string>());
                    const QString outputValue = QString::fromStdString(
                        output.second.as<std::string>());
                    QString formattedValue = formatConditionForVerilog(outputValue);
                    out << "                    " << fsmNameLower << "_" << outputName
                        << "_reg = " << formattedValue << ";\n";
                }
            }

            out << "                end\n";
        }
        out << "            default: begin\n";
        for (const QString &output : allOutputs) {
            out << "                " << fsmNameLower << "_" << output << "_reg = 1'b0;\n";
        }
        out << "            end\n";
        out << "        endcase\n";
        out << "    end\n\n";
    }

    /* Generate Mealy outputs */
    if (fsmItem["mealy"] && fsmItem["mealy"].IsSequence()) {
        out << "    /* " << fsmName << " Mealy outputs */\n";
        for (const auto &mealyEntry : fsmItem["mealy"]) {
            if (!mealyEntry.IsMap() || !mealyEntry["cond"] || !mealyEntry["sig"]
                || !mealyEntry["val"]) {
                continue;
            }

            const QString condition = QString::fromStdString(mealyEntry["cond"].as<std::string>());
            const QString signal    = QString::fromStdString(mealyEntry["sig"].as<std::string>());
            const QString value     = QString::fromStdString(mealyEntry["val"].as<std::string>());

            /* Replace cur_state with prefixed version in condition */
            QString processedCondition = condition;
            /* Only replace bare 'cur_state' if it doesn't already have the FSM prefix */
            QString prefixedPattern = fsmNameLower + "_cur_state";
            if (!processedCondition.contains(prefixedPattern)) {
                processedCondition.replace("cur_state", prefixedPattern);
            }

            /* Format the condition for proper Verilog syntax */
            QString formattedCondition = formatConditionForVerilog(processedCondition);
            QString formattedValue     = formatConditionForVerilog(value);

            out << "    assign " << signal << " = (" << formattedCondition << ") ? "
                << formattedValue << " : 1'b0;\n";
        }
        out << "\n";
    }
}

/**
 * @brief Generate Microcode-mode FSM Verilog code
 * @param fsmItem The YAML node containing the FSM specification
 * @param out Output text stream
 */
void QSocGenerateManager::generateMicrocodeFSM(const YAML::Node &fsmItem, QTextStream &out)
{
    const QString fsmName      = QString::fromStdString(fsmItem["name"].as<std::string>());
    const QString fsmNameUpper = fsmName.toUpper();
    const QString fsmNameLower = fsmName.toLower();
    const QString clkSignal    = QString::fromStdString(fsmItem["clk"].as<std::string>());
    const QString rstSignal    = QString::fromStdString(fsmItem["rst"].as<std::string>());
    const QString rstState     = QString::fromStdString(fsmItem["rst_state"].as<std::string>());

    /* Get ROM mode (default to parameter) */
    QString romMode = "parameter";
    if (fsmItem["rom_mode"] && fsmItem["rom_mode"].IsScalar()) {
        romMode = QString::fromStdString(fsmItem["rom_mode"].as<std::string>());
    }

    /* Parse fields */
    QMap<QString, QPair<int, int>> fields;
    int                            maxBit = -1;

    if (fsmItem["fields"] && fsmItem["fields"].IsMap()) {
        for (const auto &fieldEntry : fsmItem["fields"]) {
            if (!fieldEntry.first.IsScalar() || !fieldEntry.second.IsSequence()
                || fieldEntry.second.size() != 2) {
                continue;
            }

            const QString fieldName = QString::fromStdString(fieldEntry.first.as<std::string>());
            const int     loBit     = fieldEntry.second[0].as<int>();
            const int     hiBit     = fieldEntry.second[1].as<int>();
            fields[fieldName]       = qMakePair(loBit, hiBit);

            if (hiBit > maxBit)
                maxBit = hiBit;
        }
    }

    /* Calculate inferred data width from fields */
    const int inferredDataWidth = maxBit + 1;

    /* Allow user to specify data width, but use inferred if user's is smaller */
    int userDataWidth = inferredDataWidth;
    if (fsmItem["data_width"] && fsmItem["data_width"].IsScalar()) {
        int userSpecified = fsmItem["data_width"].as<int>();
        userDataWidth     = qMax(userSpecified, inferredDataWidth);
    }

    const int dataWidth = userDataWidth;

    out << "\n    /* " << fsmName << " : microcode FSM with ";
    if (romMode == "port") {
        out << "programmable ROM */\n";
    } else {
        out << "constant ROM */\n";
    }

    /* Calculate address width based on actual usage */
    int inferredRomDepth = 32; /* Default for port mode */
    if (romMode == "port" && fsmItem["rom_depth"] && fsmItem["rom_depth"].IsScalar()) {
        inferredRomDepth = fsmItem["rom_depth"].as<int>();
    } else if (fsmItem["rom"] && fsmItem["rom"].IsMap()) {
        /* For parameter mode, calculate depth based on max address and next field values */
        int maxAddress = 0;
        for (const auto &romEntry : fsmItem["rom"]) {
            if (romEntry.first.IsScalar()) {
                int address = romEntry.first.as<int>();
                if (address > maxAddress) {
                    maxAddress = address;
                }
                /* Also check next field values if they exist */
                if (romEntry.second.IsMap() && fields.contains("next")) {
                    if (romEntry.second["next"]) {
                        int nextValue = romEntry.second["next"].as<int>();
                        if (nextValue > maxAddress) {
                            maxAddress = nextValue;
                        }
                    }
                }
            }
        }
        inferredRomDepth = maxAddress + 1; /* Exact depth needed */
    }

    /* Allow user to specify ROM depth, but use inferred if user's is smaller */
    int userRomDepth = inferredRomDepth;
    if (fsmItem["rom_depth"] && fsmItem["rom_depth"].IsScalar()) {
        int userSpecified = fsmItem["rom_depth"].as<int>();
        userRomDepth      = qMax(userSpecified, inferredRomDepth);
    }

    const int romDepth = userRomDepth;

    /* Calculate address width from ROM depth */
    int inferredAddressWidth = 1;
    while ((1 << inferredAddressWidth) < romDepth) {
        inferredAddressWidth++;
    }

    /* Allow user to specify address width, but use inferred if user's is smaller */
    int userAddressWidth = inferredAddressWidth;
    if (fsmItem["addr_width"] && fsmItem["addr_width"].IsScalar()) {
        int userSpecified = fsmItem["addr_width"].as<int>();
        userAddressWidth  = qMax(userSpecified, inferredAddressWidth);
    }

    const int addressWidth = userAddressWidth;

    /* Check if user wants parameters instead of localparams for external configuration */
    bool useParameters = false;
    if (fsmItem["use_parameters"] && fsmItem["use_parameters"].IsScalar()) {
        useParameters = fsmItem["use_parameters"].as<bool>();
    }

    QString paramType = useParameters ? "parameter" : "localparam";
    out << "    " << paramType << " " << fsmNameUpper << "_AW = " << addressWidth << ";\n";
    out << "    " << paramType << " " << fsmNameUpper << "_DW = " << (dataWidth - 1) << ";\n\n";

    /* Generate program counter */
    out << "    /* " << fsmName << " program counter */\n";
    out << "    reg [" << fsmNameUpper << "_AW-1:0] " << fsmNameLower << "_pc, " << fsmNameLower
        << "_nxt_pc;\n\n";

    /* Generate ROM array */
    out << "    /* " << fsmName << " ROM array */\n";
    out << "    reg [" << fsmNameUpper << "_DW:0] " << fsmNameLower << "_rom [0:(1<<"
        << fsmNameUpper << "_AW)-1];\n\n";

    if (romMode == "parameter") {
        /* Generate ROM initialization for parameter mode */
        if (fsmItem["rom_init_file"] && fsmItem["rom_init_file"].IsScalar()) {
            /* Use $readmemh for file initialization */
            const QString initFile = QString::fromStdString(
                fsmItem["rom_init_file"].as<std::string>());
            out << "    /* " << fsmName << " ROM initialization from file */\n";
            out << "    initial begin\n";
            out << "        $readmemh(\"" << initFile << "\", " << fsmNameLower << "_rom);\n";
            out << "    end\n\n";
        } else if (fsmItem["rom"] && fsmItem["rom"].IsMap()) {
            /* Generate reset-time ROM initialization */
            out << "    /* " << fsmName << " reset-time ROM initialization */\n";
            out << "    always @(posedge " << clkSignal << " or negedge " << rstSignal
                << ") begin\n";
            out << "        if (!" << rstSignal << ") begin\n";

            for (const auto &romEntry : fsmItem["rom"]) {
                if (!romEntry.first.IsScalar() || !romEntry.second.IsMap()) {
                    continue;
                }

                const int address = romEntry.first.as<int>();

                /* Build the ROM word from fields - sort by high bit position for correct ordering */
                QMap<int, QString> romPartsMap; /* key = high bit position, value = field part */
                for (auto it = fields.begin(); it != fields.end(); ++it) {
                    const QString         &fieldName = it.key();
                    const QPair<int, int> &bitRange  = it.value();

                    QString fieldPart;
                    if (romEntry.second[fieldName.toStdString()]) {
                        const QString fieldValue = QString::fromStdString(
                            romEntry.second[fieldName.toStdString()].as<std::string>());
                        const int fieldWidth = bitRange.second - bitRange.first + 1;
                        /* Handle hexadecimal values properly */
                        if (fieldValue.startsWith("0x") || fieldValue.startsWith("0X")) {
                            QString hexValue = fieldValue.mid(2); /* Remove 0x prefix */
                            fieldPart        = QString("%1'h%2").arg(fieldWidth).arg(hexValue);
                        } else {
                            fieldPart = QString("%1'd%2").arg(fieldWidth).arg(fieldValue);
                        }
                    } else {
                        const int fieldWidth = bitRange.second - bitRange.first + 1;
                        fieldPart            = QString("%1'd0").arg(fieldWidth);
                    }
                    romPartsMap[bitRange.second] = fieldPart;
                }

                /* Convert map to list in descending bit order */
                QStringList romParts;
                for (auto it = romPartsMap.end(); it != romPartsMap.begin();) {
                    --it;
                    romParts.append(it.value());
                }

                /* Calculate total bits used by all defined fields */
                int totalFieldBits = 0;
                for (auto fieldIt = fields.begin(); fieldIt != fields.end(); ++fieldIt) {
                    const QPair<int, int> &bitRange   = fieldIt.value();
                    int                    fieldWidth = bitRange.second - bitRange.first + 1;
                    totalFieldBits += fieldWidth;
                }

                /* Add padding if dataWidth is larger than total field bits */
                if (totalFieldBits < dataWidth) {
                    int paddingBits = dataWidth - totalFieldBits;
                    romParts.prepend(QString("%1'd0").arg(paddingBits));
                }

                out << "            " << fsmNameLower << "_rom[" << address << "] <= {"
                    << romParts.join(", ") << "};\n";
            }

            out << "        end\n";
            out << "    end\n\n";
        }
    } else {
        /* Generate write port for programmable ROM */
        out << "    /* " << fsmName << " write port */\n";
        out << "    always @(posedge " << clkSignal << ")\n";
        out << "        if (" << fsmNameLower << "_rom_we) " << fsmNameLower << "_rom["
            << fsmNameLower << "_rom_addr] <= " << fsmNameLower << "_rom_wdata[" << fsmNameUpper
            << "_DW:0];\n\n";
    }

    /* Generate branch decode logic */
    if (fields.contains("branch") && fields.contains("next")) {
        out << "    /* " << fsmName << " branch decode */\n";
        out << "    always @(*) begin\n";
        out << "        " << fsmNameLower << "_nxt_pc = " << fsmNameLower << "_pc + 1'b1;\n";

        const QPair<int, int> &branchRange = fields["branch"];
        const QPair<int, int> &nextRange   = fields["next"];

        out << "        case (" << fsmNameLower << "_rom[" << fsmNameLower << "_pc]["
            << branchRange.second << ":" << branchRange.first << "])\n";
        out << "            2'd0: " << fsmNameLower << "_nxt_pc = " << fsmNameLower
            << "_pc + 1'b1;\n";
        out << "            2'd1: if (cond)  " << fsmNameLower << "_nxt_pc = " << fsmNameLower
            << "_rom[" << fsmNameLower << "_pc][" << nextRange.second << ":" << nextRange.first
            << "][" << fsmNameUpper << "_AW-1:0];\n";
        out << "            2'd2: if (!cond) " << fsmNameLower << "_nxt_pc = " << fsmNameLower
            << "_rom[" << fsmNameLower << "_pc][" << nextRange.second << ":" << nextRange.first
            << "][" << fsmNameUpper << "_AW-1:0];\n";
        out << "            2'd3: " << fsmNameLower << "_nxt_pc = " << fsmNameLower << "_rom["
            << fsmNameLower << "_pc][" << nextRange.second << ":" << nextRange.first << "]["
            << fsmNameUpper << "_AW-1:0];\n";
        out << "            default: " << fsmNameLower << "_nxt_pc = " << fsmNameLower
            << "_pc + 1'b1;\n";
        out << "        endcase\n";
        out << "    end\n\n";
    }

    /* Generate PC register */
    out << "    /* " << fsmName << " pc register */\n";
    out << "    always @(posedge " << clkSignal << " or negedge " << rstSignal << ")\n";
    out << "        if (!" << rstSignal << ") " << fsmNameLower << "_pc <= " << addressWidth << "'d"
        << rstState << ";\n";
    out << "        else        " << fsmNameLower << "_pc <= " << fsmNameLower << "_nxt_pc;\n\n";

    /* Generate control outputs */
    out << "    /* " << fsmName << " control outputs */\n";
    for (auto it = fields.begin(); it != fields.end(); ++it) {
        const QString         &fieldName = it.key();
        const QPair<int, int> &bitRange  = it.value();

        if (fieldName != "branch" && fieldName != "next") {
            /* Map field names to actual output port names */
            QString outputPortName = fieldName;
            if (fieldName == "ctrl") {
                outputPortName = "ctrl_bus"; /* Map ctrl field to ctrl_bus port */
            }

            if (bitRange.first == bitRange.second) {
                out << "    assign " << outputPortName << " = " << fsmNameLower << "_rom["
                    << fsmNameLower << "_pc][" << bitRange.first << "];\n";
            } else {
                out << "    assign " << outputPortName << " = " << fsmNameLower << "_rom["
                    << fsmNameLower << "_pc][" << bitRange.second << ":" << bitRange.first
                    << "];\n";
            }
        }
    }
    out << "\n";
}
