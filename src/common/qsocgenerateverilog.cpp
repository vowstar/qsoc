// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: 2025 Huang Rui <vowstar@gmail.com>

#include "common/qsocgeneratemanager.h"
#include "common/qstaticstringweaver.h"

#include <QCoreApplication>
#include <QDebug>
#include <QDir>
#include <QFile>
#include <QFileInfo>
#include <QProcess>
#include <QRegularExpression>
#include <QTextStream>

#include <fstream>
#include <iostream>

bool QSocGenerateManager::generateVerilog(const QString &outputFileName)
{
    /* Check if netlistData is valid */
    if (!netlistData["instance"]) {
        qCritical() << "Error: Invalid netlist data, missing 'instance' section, make sure "
                       "loadNetlist() and processNetlist() have been called";
        return false;
    }

    if (!netlistData["instance"].IsMap() || netlistData["instance"].size() == 0) {
        qCritical() << "Error: Invalid netlist data, 'instance' section is empty or not a map";
        return false;
    }

    /* Check if net section exists and has valid format if present */
    if (netlistData["net"] && !netlistData["net"].IsMap()) {
        qCritical() << "Error: Invalid netlist data, 'net' section is not a map";
        return false;
    }

    /* Check if project manager is valid */
    if (!projectManager) {
        qCritical() << "Error: Project manager is null";
        return false;
    }

    if (!projectManager->isValidOutputPath(true)) {
        qCritical() << "Error: Invalid output path: " << projectManager->getOutputPath();
        return false;
    }

    /* Prepare output file path */
    const QString outputFilePath
        = QDir(projectManager->getOutputPath()).filePath(outputFileName + ".v");

    /* Open output file for writing */
    QFile outputFile(outputFilePath);
    if (!outputFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
        qCritical() << "Error: Failed to open output file for writing:" << outputFilePath;
        return false;
    }

    QTextStream out(&outputFile);

    /* Generate file header */
    out << "/**\n";
    out << " * @file " << outputFileName << ".v\n";
    out << " * @brief RTL implementation of " << outputFileName << "\n";
    out << " *\n";
    out << " * @details This file contains RTL implementation based on the input netlist.\n"
        << " *          Auto-generated RTL Verilog file. Generated by "
        << QCoreApplication::applicationName() << " " << QCoreApplication::applicationVersion()
        << ".\n";
    out << " * NOTE: Auto-generated file, do not edit manually.\n";
    out << " */\n\n";

    /* Generate module declaration */
    out << "module " << outputFileName;

    /* Add module parameters if they exist */
    if (netlistData["parameter"] && netlistData["parameter"].IsMap()
        && netlistData["parameter"].size() > 0) {
        out << " #(\n";
        QStringList paramDeclarations;

        for (auto paramIter = netlistData["parameter"].begin();
             paramIter != netlistData["parameter"].end();
             ++paramIter) {
            if (!paramIter->first.IsScalar()) {
                qWarning() << "Warning: Invalid parameter name, skipping";
                continue;
            }

            const QString paramName = QString::fromStdString(paramIter->first.as<std::string>());

            if (!paramIter->second.IsMap()) {
                qWarning() << "Warning: Parameter" << paramName << "has invalid format, skipping";
                continue;
            }

            /* Default to empty for Verilog 2001 */
            QString paramType  = "";
            QString paramValue = "";

            if (paramIter->second["type"] && paramIter->second["type"].IsScalar()) {
                paramType = QString::fromStdString(paramIter->second["type"].as<std::string>());
                /* Strip out 'logic' keyword for Verilog 2001 compatibility */
                paramType = paramType.replace(QRegularExpression("\\blogic(\\s+|\\b)"), "");

                /* Add a space if type isn't empty after processing */
                if (!paramType.isEmpty() && !paramType.endsWith(" ")) {
                    paramType += " ";
                }
            }

            if (paramIter->second["value"] && paramIter->second["value"].IsScalar()) {
                paramValue = QString::fromStdString(paramIter->second["value"].as<std::string>());
            }

            paramDeclarations.append(
                QString("    parameter %1%2 = %3").arg(paramType).arg(paramName).arg(paramValue));
        }

        if (!paramDeclarations.isEmpty()) {
            out << paramDeclarations.join(",\n") << "\n";
        }
        out << ")";
    }

    /* Start port list */
    out << " (";

    /* Collect all ports for module interface */
    QStringList            ports;
    QMap<QString, QString> portToNetConnections; /* Map of port name to connected net name */

    /* Process port section if it exists */
    if (netlistData["port"] && netlistData["port"].IsMap()) {
        for (auto portIter = netlistData["port"].begin(); portIter != netlistData["port"].end();
             ++portIter) {
            if (!portIter->first.IsScalar()) {
                qWarning() << "Warning: Invalid port name, skipping";
                continue;
            }

            const QString portName = QString::fromStdString(portIter->first.as<std::string>());

            if (!portIter->second.IsMap()) {
                qWarning() << "Warning: Port" << portName << "has invalid format, skipping";
                continue;
            }

            QString direction = "input";
            QString type      = ""; /* Empty type by default for Verilog 2001 */

            if (portIter->second["direction"] && portIter->second["direction"].IsScalar()) {
                QString dirStr = QString::fromStdString(
                                     portIter->second["direction"].as<std::string>())
                                     .toLower();

                /* Handle both full and abbreviated forms */
                if (dirStr == "out" || dirStr == "output") {
                    direction = "output";
                } else if (dirStr == "in" || dirStr == "input") {
                    direction = "input";
                } else if (dirStr == "inout") {
                    direction = "inout";
                }
            }

            /* Get port type/width information if present */
            if (portIter->second["type"] && portIter->second["type"].IsScalar()) {
                type = QString::fromStdString(portIter->second["type"].as<std::string>());
                /* Strip out 'logic' keyword for Verilog 2001 compatibility */
                type = type.replace(QRegularExpression("\\blogic(\\s+|\\b)"), "");
            }

            /* Store the connection information if present */
            if (portIter->second["connect"] && portIter->second["connect"].IsScalar()) {
                QString connectedNet = QString::fromStdString(
                    portIter->second["connect"].as<std::string>());
                portToNetConnections[portName] = connectedNet;
            }

            /* Add port declaration */
            ports.append(QString("%1 %2").arg(direction).arg(
                type.isEmpty() ? portName : type + " " + portName));
        }
    }

    /* Close module declaration */
    if (!ports.isEmpty()) {
        /* If we have parameters, add a comma after them */
        out << "\n    " << ports.join(",\n    ") << "\n";
    }
    out << ");\n\n";

    /* Build a mapping of all connections for each instance and port */
    QMap<QString, QMap<QString, QString>> instancePortConnections;

    /* First, create the instancePortConnections map with port connections */
    /* This needs to be done before wire generation to ensure port names are used */
    if (netlistData["net"] && netlistData["net"].IsMap()) {
        for (auto netIter = netlistData["net"].begin(); netIter != netlistData["net"].end();
             ++netIter) {
            if (!netIter->first.IsScalar()) {
                continue;
            }

            const QString netName = QString::fromStdString(netIter->first.as<std::string>());

            /* Check if this net is connected to a top-level port */
            QString connectedPortName;
            bool    connectedToTopPort = false;

            for (auto it = portToNetConnections.begin(); it != portToNetConnections.end(); ++it) {
                if (it.value() == netName) {
                    connectedToTopPort = true;
                    connectedPortName  = it.key();
                    break;
                }
            }

            try {
                /* Build connections using port names where appropriate */
                const YAML::Node &netNode = netIter->second;
                if (netNode.IsMap()) {
                    for (const auto &instancePair : netNode) {
                        if (instancePair.first.IsScalar()) {
                            const QString instanceName = QString::fromStdString(
                                instancePair.first.as<std::string>());
                            if (!instancePortConnections.contains(instanceName)) {
                                instancePortConnections[instanceName] = QMap<QString, QString>();
                            }

                            if (instancePair.second.IsMap()
                                && instancePair.second["port"].IsScalar()) {
                                const QString portName = QString::fromStdString(
                                    instancePair.second["port"].as<std::string>());

                                /* Check if this port has invert attribute */
                                bool hasInvert = false;
                                if (netlistData["instance"]
                                    && netlistData["instance"][instanceName.toStdString()]
                                    && netlistData["instance"][instanceName.toStdString()]["port"]
                                    && netlistData["instance"][instanceName.toStdString()]["port"]
                                                  [portName.toStdString()]) {
                                    auto portNode
                                        = netlistData["instance"][instanceName.toStdString()]
                                                     ["port"][portName.toStdString()];
                                    if (portNode["invert"] && portNode["invert"].IsScalar()) {
                                        /* Use direct YAML boolean parsing */
                                        if (portNode["invert"].as<bool>()) {
                                            hasInvert = true;
                                        }
                                    }
                                }

                                /* Initialize bitSelect as empty string */
                                QString bitSelect = "";

                                /* Check if this port has bits selection attribute */
                                if (instancePair.second["bits"]
                                    && instancePair.second["bits"].IsScalar()) {
                                    bitSelect = QString::fromStdString(
                                        instancePair.second["bits"].as<std::string>());
                                }

                                /* If connected to top-level port, use the port name instead of net name */
                                if (connectedToTopPort) {
                                    instancePortConnections[instanceName][portName]
                                        = hasInvert
                                              ? QString("~%1%2")
                                                    .arg(connectedPortName)
                                                    .arg(bitSelect.isEmpty() ? "" : bitSelect)
                                              : QString("%1%2")
                                                    .arg(connectedPortName)
                                                    .arg(bitSelect.isEmpty() ? "" : bitSelect);
                                } else {
                                    instancePortConnections[instanceName][portName]
                                        = hasInvert ? QString("~%1%2").arg(netName).arg(
                                                          bitSelect.isEmpty() ? "" : bitSelect)
                                                    : QString("%1%2").arg(netName).arg(
                                                          bitSelect.isEmpty() ? "" : bitSelect);
                                }
                            }
                        }
                    }
                }
            } catch (const std::exception &e) {
                qWarning() << "Error processing net:" << e.what();
            }
        }
    }

    /* Add connections (wires) section comment */
    out << "    /* Wire declarations */\n";

    /* Generate wire declarations FIRST */
    if (netlistData["net"]) {
        if (!netlistData["net"].IsMap()) {
            qWarning() << "Warning: 'net' section is not a map, skipping wire declarations";
        } else if (netlistData["net"].size() == 0) {
            qWarning() << "Warning: 'net' section is empty, no wire declarations to generate";
        } else {
            for (auto netIter = netlistData["net"].begin(); netIter != netlistData["net"].end();
                 ++netIter) {
                if (!netIter->first.IsScalar()) {
                    qWarning() << "Warning: Invalid net name, skipping";
                    continue;
                }

                const QString netName = QString::fromStdString(netIter->first.as<std::string>());

                if (!netIter->second) {
                    qWarning() << "Warning: Net" << netName << "has null data, skipping";
                    continue;
                }

                /* Net connections should be a map of instance-port pairs */
                if (!netIter->second.IsMap()) {
                    qWarning() << "Warning: Net" << netName << "is not a map, skipping";
                    continue;
                }

                const YAML::Node &connections = netIter->second;

                if (connections.size() == 0) {
                    qWarning() << "Warning: Net" << netName << "has no connections, skipping";
                    continue;
                }

                /* Build a list of instance-port pairs for width check */
                QList<PortConnection> portConnections;
                /* Collect detailed port information for each connection */
                QList<PortDetailInfo> portDetails;

                /* Check if this net is connected to a top-level port */
                bool    connectedToTopPort = false;
                QString connectedPortName;
                QString topLevelPortDirection = "unknown";

                /* Check if this net is connected to a top-level port */
                for (auto it = portToNetConnections.begin(); it != portToNetConnections.end();
                     ++it) {
                    if (it.value() == netName) {
                        connectedToTopPort = true;
                        connectedPortName  = it.key();

                        /* Get the port direction */
                        if (netlistData["port"]
                            && netlistData["port"][connectedPortName.toStdString()]
                            && netlistData["port"][connectedPortName.toStdString()]["direction"]
                            && netlistData["port"][connectedPortName.toStdString()]["direction"]
                                   .IsScalar()) {
                            QString dirStr = QString::fromStdString(
                                                 netlistData["port"][connectedPortName.toStdString()]
                                                            ["direction"]
                                                                .as<std::string>())
                                                 .toLower();

                            /* Store original direction for later use */
                            if (dirStr == "out" || dirStr == "output") {
                                topLevelPortDirection = "output";
                            } else if (dirStr == "in" || dirStr == "input") {
                                topLevelPortDirection = "input";
                            } else if (dirStr == "inout") {
                                topLevelPortDirection = "inout";
                            }

                            /* Reverse the direction for internal checking */
                            QString reversedDirection;
                            if (topLevelPortDirection == "output") {
                                reversedDirection
                                    = "input"; /* Top-level output is an input for internal nets */
                            } else if (topLevelPortDirection == "input") {
                                reversedDirection
                                    = "output"; /* Top-level input is an output for internal nets */
                            } else if (topLevelPortDirection == "inout") {
                                reversedDirection = "inout"; /* Bidirectional remains bidirectional */
                            }

                            /* Add top-level port to connection list */
                            portConnections.append(
                                PortConnection::createTopLevelPort(connectedPortName));

                            /* Get port width */
                            QString portWidth = "";
                            if (netlistData["port"]
                                && netlistData["port"][connectedPortName.toStdString()]) {
                                auto portNode = netlistData["port"][connectedPortName.toStdString()];

                                /* Get port direction */
                                QString portDirection = "unknown";
                                if (portNode["direction"] && portNode["direction"].IsScalar()) {
                                    QString dirStr = QString::fromStdString(
                                                         portNode["direction"].as<std::string>())
                                                         .toLower();

                                    /* Handle both full and abbreviated forms */
                                    if (dirStr == "out" || dirStr == "output") {
                                        portDirection = "output";
                                    } else if (dirStr == "in" || dirStr == "input") {
                                        portDirection = "input";
                                    } else if (dirStr == "inout") {
                                        portDirection = "inout";
                                    }
                                }

                                /* Get port width/type */
                                if (portNode["type"] && portNode["type"].IsScalar()) {
                                    portWidth = QString::fromStdString(
                                        portNode["type"].as<std::string>());
                                }
                            }

                            /* Initialize bitSelect as empty string */
                            QString bitSelect = "";

                            /* Add to detailed port information with reversed direction */
                            portDetails.append(
                                PortDetailInfo::createTopLevelPort(
                                    connectedPortName, portWidth, reversedDirection, bitSelect));
                        }
                        break;
                    }
                }

                /* Build port connections from netlistData */
                const YAML::Node &netNode = netlistData["net"][netName.toStdString()];
                if (netNode.IsMap()) {
                    for (const auto &instancePair : netNode) {
                        if (instancePair.first.IsScalar()) {
                            QString instanceName = QString::fromStdString(
                                instancePair.first.as<std::string>());

                            /* Verify this is a valid instance with a port */
                            if (instancePair.second.IsMap() && instancePair.second["port"]
                                && instancePair.second["port"].IsScalar()) {
                                QString portName = QString::fromStdString(
                                    instancePair.second["port"].as<std::string>());

                                /* Create a module port connection */
                                portConnections.append(
                                    PortConnection::createModulePort(instanceName, portName));

                                /* Get additional details for this port */
                                QString portWidth     = "";
                                QString portDirection = "unknown";

                                /* Check if this port has bits selection attribute */
                                QString bitSelect = "";
                                if (instancePair.second["bits"]
                                    && instancePair.second["bits"].IsScalar()) {
                                    bitSelect = QString::fromStdString(
                                        instancePair.second["bits"].as<std::string>());
                                }

                                /* Get instance's module */
                                if (netlistData["instance"][instanceName.toStdString()]
                                    && netlistData["instance"][instanceName.toStdString()]["module"]
                                    && netlistData["instance"][instanceName.toStdString()]["module"]
                                           .IsScalar()) {
                                    QString moduleName = QString::fromStdString(
                                        netlistData["instance"][instanceName.toStdString()]
                                                   ["module"]
                                                       .as<std::string>());

                                    /* Get module definition */
                                    if (moduleManager && moduleManager->isModuleExist(moduleName)) {
                                        YAML::Node moduleData = moduleManager->getModuleYaml(
                                            moduleName);

                                        if (moduleData["port"] && moduleData["port"].IsMap()
                                            && moduleData["port"][portName.toStdString()]) {
                                            /* Get port width */
                                            if (moduleData["port"][portName.toStdString()]["type"]
                                                && moduleData["port"][portName.toStdString()]
                                                             ["type"]
                                                                 .IsScalar()) {
                                                portWidth = QString::fromStdString(
                                                    moduleData["port"][portName.toStdString()]
                                                              ["type"]
                                                                  .as<std::string>());
                                                /* Strip out 'logic' keyword for Verilog 2001 compatibility */
                                                portWidth = portWidth.replace(
                                                    QRegularExpression("\\blogic(\\s+|\\b)"), "");
                                            }

                                            /* Get port direction */
                                            if (moduleData["port"][portName.toStdString()]
                                                          ["direction"]
                                                && moduleData["port"][portName.toStdString()]
                                                             ["direction"]
                                                                 .IsScalar()) {
                                                portDirection = QString::fromStdString(
                                                    moduleData["port"][portName.toStdString()]
                                                              ["direction"]
                                                                  .as<std::string>());
                                                /* Handle both full and abbreviated forms */
                                                if (portDirection == "out"
                                                    || portDirection == "output") {
                                                    portDirection = "output";
                                                } else if (
                                                    portDirection == "in"
                                                    || portDirection == "input") {
                                                    portDirection = "input";
                                                } else if (portDirection == "inout") {
                                                    portDirection = "inout";
                                                }
                                            }
                                        }
                                    }
                                }

                                /* Add to detailed port information */
                                portDetails.append(
                                    PortDetailInfo::createModulePort(
                                        instanceName, portName, portWidth, portDirection, bitSelect));
                            }
                        }
                    }
                }

                /* Check port width consistency */
                bool hasWidthMismatch = !checkPortWidthConsistency(portConnections);
                if (hasWidthMismatch) {
                    qWarning() << "Warning: Port width mismatch detected for net" << netName;
                }

                /* Check port direction consistency */
                PortDirectionStatus dirStatus    = checkPortDirectionConsistency(portConnections);
                bool                isUndriven   = (dirStatus == PortDirectionStatus::Undriven);
                bool                isMultidrive = (dirStatus == PortDirectionStatus::Multidrive);

                if (isUndriven) {
                    qWarning() << "Warning: Net" << netName
                               << "has only input ports, missing driver";
                } else if (isMultidrive) {
                    qWarning() << "Warning: Net" << netName << "has multiple output/inout ports";
                }

                /* Generate combined warning comments for the net */
                if (hasWidthMismatch || isUndriven || isMultidrive) {
                    /* Output width mismatch warning if detected */
                    if (hasWidthMismatch) {
                        if (connectedToTopPort) {
                            out << "    /* FIXME: Port " << connectedPortName << " (net " << netName
                                << ") width mismatch - please check connected ports:\n";
                        } else {
                            out << "    /* FIXME: Net " << netName
                                << " width mismatch - please check connected ports:\n";
                        }

                        /* Add detailed information for each connected port */
                        for (const auto &detail : portDetails) {
                            if (detail.type == PortType::TopLevel) {
                                /* For top-level ports, we need to display the original direction, not the reversed one */
                                QString displayDirection = detail.direction;
                                /* input -> output, output -> input, inout -> inout */
                                if (displayDirection == "input") {
                                    displayDirection = "output";
                                } else if (displayDirection == "output") {
                                    displayDirection = "input";
                                }

                                out << "     *   Top-Level Port: " << detail.portName
                                    << ", Direction: " << displayDirection << ", Width: "
                                    << (detail.width.isEmpty() ? "default" : detail.width)
                                    << (detail.bitSelect.isEmpty()
                                            ? ""
                                            : ", Bit Selection: " + detail.bitSelect)
                                    << "\n";
                            } else {
                                /* Regular instance port */
                                if (netlistData["instance"][detail.instanceName.toStdString()]
                                    && netlistData["instance"][detail.instanceName.toStdString()]
                                                  ["module"]
                                    && netlistData["instance"][detail.instanceName.toStdString()]
                                                  ["module"]
                                                      .IsScalar()) {
                                    out << "     *   Module: "
                                        << netlistData["instance"]
                                                      [detail.instanceName.toStdString()]["module"]
                                                          .as<std::string>()
                                                          .c_str()
                                        << ", Instance: " << detail.instanceName
                                        << ", Port: " << detail.portName
                                        << ", Direction: " << detail.direction << ", Width: "
                                        << (detail.width.isEmpty() ? "default" : detail.width)
                                        << (detail.bitSelect.isEmpty()
                                                ? ""
                                                : ", Bit Selection: " + detail.bitSelect)
                                        << "\n";
                                } else {
                                    /* Handle case where instance data might be invalid */
                                    out << "     *   Instance: " << detail.instanceName
                                        << ", Port: " << detail.portName
                                        << ", Direction: " << detail.direction << ", Width: "
                                        << (detail.width.isEmpty() ? "default" : detail.width)
                                        << (detail.bitSelect.isEmpty()
                                                ? ""
                                                : ", Bit Selection: " + detail.bitSelect)
                                        << "\n";
                                }
                            }
                        }
                        out << "     */\n";
                    }

                    /* Output undriven warning if detected */
                    if (isUndriven) {
                        if (connectedToTopPort) {
                            out << "    /* FIXME: Port " << connectedPortName << " (net " << netName
                                << ") is undriven - missing source:\n";
                        } else {
                            out << "    /* FIXME: Net " << netName
                                << " is undriven - missing source:\n";
                        }

                        /* Add detailed information for each connected port */
                        for (const auto &detail : portDetails) {
                            if (detail.type == PortType::TopLevel) {
                                /* For top-level ports, we need to display the original direction, not the reversed one */
                                QString displayDirection = detail.direction;
                                if (displayDirection == "input") {
                                    displayDirection = "output";
                                } else if (displayDirection == "output") {
                                    displayDirection = "input";
                                }
                                /* inout remains inout */

                                out << "     *   Top-Level Port: " << detail.portName
                                    << ", Direction: " << displayDirection << ", Width: "
                                    << (detail.width.isEmpty() ? "default" : detail.width)
                                    << (detail.bitSelect.isEmpty()
                                            ? ""
                                            : ", Bit Selection: " + detail.bitSelect)
                                    << "\n";
                            } else {
                                /* Regular instance port */
                                if (netlistData["instance"][detail.instanceName.toStdString()]
                                    && netlistData["instance"][detail.instanceName.toStdString()]
                                                  ["module"]
                                    && netlistData["instance"][detail.instanceName.toStdString()]
                                                  ["module"]
                                                      .IsScalar()) {
                                    out << "     *   Module: "
                                        << netlistData["instance"]
                                                      [detail.instanceName.toStdString()]["module"]
                                                          .as<std::string>()
                                                          .c_str()
                                        << ", Instance: " << detail.instanceName
                                        << ", Port: " << detail.portName
                                        << ", Direction: " << detail.direction << ", Width: "
                                        << (detail.width.isEmpty() ? "default" : detail.width)
                                        << (detail.bitSelect.isEmpty()
                                                ? ""
                                                : ", Bit Selection: " + detail.bitSelect)
                                        << "\n";
                                } else {
                                    /* Handle case where instance data might be invalid */
                                    out << "     *   Instance: " << detail.instanceName
                                        << ", Port: " << detail.portName
                                        << ", Direction: " << detail.direction << ", Width: "
                                        << (detail.width.isEmpty() ? "default" : detail.width)
                                        << (detail.bitSelect.isEmpty()
                                                ? ""
                                                : ", Bit Selection: " + detail.bitSelect)
                                        << "\n";
                                }
                            }
                        }
                        out << "     */\n";
                    }

                    /* Output multidrive warning if detected */
                    if (isMultidrive) {
                        if (connectedToTopPort) {
                            out << "    /* FIXME: Port " << connectedPortName << " (net " << netName
                                << ") has multiple drivers - potential conflict:\n";
                        } else {
                            out << "    /* FIXME: Net " << netName
                                << " has multiple drivers - potential conflict:\n";
                        }

                        /* Add detailed information for each connected port */
                        for (const auto &detail : portDetails) {
                            if (detail.type == PortType::TopLevel) {
                                /* For top-level ports, we need to display the original direction, not the reversed one */
                                QString displayDirection = detail.direction;
                                if (displayDirection == "input") {
                                    displayDirection = "output";
                                } else if (displayDirection == "output") {
                                    displayDirection = "input";
                                }
                                /* inout remains inout */

                                out << "     *   Top-Level Port: " << detail.portName
                                    << ", Direction: " << displayDirection << ", Width: "
                                    << (detail.width.isEmpty() ? "default" : detail.width)
                                    << (detail.bitSelect.isEmpty()
                                            ? ""
                                            : ", Bit Selection: " + detail.bitSelect)
                                    << "\n";
                            } else {
                                /* Regular instance port */
                                if (netlistData["instance"][detail.instanceName.toStdString()]
                                    && netlistData["instance"][detail.instanceName.toStdString()]
                                                  ["module"]
                                    && netlistData["instance"][detail.instanceName.toStdString()]
                                                  ["module"]
                                                      .IsScalar()) {
                                    out << "     *   Module: "
                                        << netlistData["instance"]
                                                      [detail.instanceName.toStdString()]["module"]
                                                          .as<std::string>()
                                                          .c_str()
                                        << ", Instance: " << detail.instanceName
                                        << ", Port: " << detail.portName
                                        << ", Direction: " << detail.direction << ", Width: "
                                        << (detail.width.isEmpty() ? "default" : detail.width)
                                        << (detail.bitSelect.isEmpty()
                                                ? ""
                                                : ", Bit Selection: " + detail.bitSelect)
                                        << "\n";
                                } else {
                                    /* Handle case where instance data might be invalid */
                                    out << "     *   Instance: " << detail.instanceName
                                        << ", Port: " << detail.portName
                                        << ", Direction: " << detail.direction << ", Width: "
                                        << (detail.width.isEmpty() ? "default" : detail.width)
                                        << (detail.bitSelect.isEmpty()
                                                ? ""
                                                : ", Bit Selection: " + detail.bitSelect)
                                        << "\n";
                                }
                            }
                        }
                        out << "     */\n";
                    }
                }

                /* Only declare wire if not connected to top-level port to avoid redundancy */
                if (!connectedToTopPort) {
                    /* Get net width from all ports connected to this net */
                    QString netWidth = "";
                    int     maxWidth = 0;

                    /* Find the port with the maximum width */
                    for (const auto &detail : portDetails) {
                        if (!detail.width.isEmpty()) {
                            /* Attempt to extract width value from format like [31:0] or [7] */
                            QRegularExpression widthRegex("\\[\\s*(\\d+)\\s*(?::\\s*\\d+)?\\s*\\]");
                            auto               match = widthRegex.match(detail.width);
                            if (match.hasMatch()) {
                                bool ok = false;
                                /* Extract the highest bit number and add 1 to get the width (e.g., [31:0] means 32 bits) */
                                int width = match.captured(1).toInt(&ok) + 1;
                                if (ok && width > maxWidth) {
                                    maxWidth = width;
                                    netWidth = detail.width;
                                }
                            } else if (maxWidth == 0) {
                                /* If no width number found but we have a type string, use it as fallback */
                                netWidth = detail.width;
                            }
                        }
                    }

                    /* If no width found from ports, try from net type as fallback */
                    if (netWidth.isEmpty() && netlistData["net"]
                        && netlistData["net"][netName.toStdString()]
                        && netlistData["net"][netName.toStdString()]["type"]
                        && netlistData["net"][netName.toStdString()]["type"].IsScalar()) {
                        netWidth = QString::fromStdString(
                            netlistData["net"][netName.toStdString()]["type"].as<std::string>());
                    }

                    /* Add wire declaration for this net with width information if available */
                    if (!netWidth.isEmpty()) {
                        out << "    wire " << netWidth << " " << netName << ";\n";
                    } else {
                        out << "    wire " << netName << ";\n";
                    }
                } else {
                    /* Check for width mismatches between port and net */
                    QString portWidth     = "";
                    QString netWidth      = "";
                    QString portDirection = "input";

                    /* Get port information */
                    if (netlistData["port"]
                        && netlistData["port"][connectedPortName.toStdString()]) {
                        auto portNode = netlistData["port"][connectedPortName.toStdString()];

                        /* Get port direction */
                        if (portNode["direction"] && portNode["direction"].IsScalar()) {
                            QString dirStr = QString::fromStdString(
                                                 portNode["direction"].as<std::string>())
                                                 .toLower();

                            /* Handle both full and abbreviated forms */
                            if (dirStr == "out" || dirStr == "output") {
                                portDirection = "output";
                            } else if (dirStr == "in" || dirStr == "input") {
                                portDirection = "input";
                            } else if (dirStr == "inout") {
                                portDirection = "inout";
                            }
                        }

                        /* Get port width/type */
                        if (portNode["type"] && portNode["type"].IsScalar()) {
                            portWidth = QString::fromStdString(portNode["type"].as<std::string>());
                        }
                    }

                    /* Get net width */
                    if (netlistData["net"] && netlistData["net"][netName.toStdString()]
                        && netlistData["net"][netName.toStdString()]["type"]
                        && netlistData["net"][netName.toStdString()]["type"].IsScalar()) {
                        netWidth = QString::fromStdString(
                            netlistData["net"][netName.toStdString()]["type"].as<std::string>());
                    }

                    /* Check width compatibility */
                    bool widthMismatch = !portWidth.isEmpty() && !netWidth.isEmpty()
                                         && portWidth != netWidth;

                    /* Add width mismatch FIXME comment if needed */
                    if (widthMismatch) {
                        out << "    /* FIXME: Port " << connectedPortName << " (net " << netName
                            << ") width mismatch - port width: " << portWidth
                            << ", net width: " << netWidth << " */\n";
                    }

                    /* Add direction warning if needed */
                    if (portDirection == "inout") {
                        out << "    /* FIXME: Port " << connectedPortName
                            << " is inout - verify bidirectional behavior */\n";
                    }
                }
            }
            out << "\n";
        }
    } else {
        qWarning()
            << "Warning: No 'net' section in netlist, no wire declarations will be generated";
    }

    /* Add instances section comment */
    out << "    /* Module instantiations */\n";

    /* Generate instance declarations after wire declarations */
    for (auto instanceIter = netlistData["instance"].begin();
         instanceIter != netlistData["instance"].end();
         ++instanceIter) {
        /* Check if the instance name is a scalar */
        if (!instanceIter->first.IsScalar()) {
            qWarning() << "Warning: Invalid instance name, skipping";
            continue;
        }

        const QString instanceName = QString::fromStdString(instanceIter->first.as<std::string>());

        /* Check if the instance data is valid */
        if (!instanceIter->second || !instanceIter->second.IsMap()) {
            qWarning() << "Warning: Invalid instance data for" << instanceName
                       << "(not a map), skipping";
            continue;
        }

        const YAML::Node &instanceData = instanceIter->second;

        if (!instanceData["module"] || !instanceData["module"].IsScalar()) {
            qWarning() << "Warning: Invalid module name for instance" << instanceName;
            continue;
        }

        const QString moduleName = QString::fromStdString(instanceData["module"].as<std::string>());

        /* Generate instance declaration with parameters if any */
        out << "    " << moduleName << " ";

        /* Add parameters if they exist */
        if (instanceData["parameter"]) {
            if (!instanceData["parameter"].IsMap()) {
                qWarning() << "Warning: 'parameter' section for instance" << instanceName
                           << "is not a map, ignoring";
            } else if (instanceData["parameter"].size() == 0) {
                qWarning() << "Warning: 'parameter' section for instance" << instanceName
                           << "is empty, ignoring";
            } else {
                out << "#(\n";

                QStringList paramList;
                for (auto paramIter = instanceData["parameter"].begin();
                     paramIter != instanceData["parameter"].end();
                     ++paramIter) {
                    if (!paramIter->first.IsScalar()) {
                        qWarning() << "Warning: Invalid parameter name in instance" << instanceName;
                        continue;
                    }

                    if (!paramIter->second.IsScalar()) {
                        qWarning()
                            << "Warning: Parameter"
                            << QString::fromStdString(paramIter->first.as<std::string>())
                            << "in instance" << instanceName << "has a non-scalar value, skipping";
                        continue;
                    }

                    const QString paramName = QString::fromStdString(
                        paramIter->first.as<std::string>());
                    const QString paramValue = QString::fromStdString(
                        paramIter->second.as<std::string>());

                    paramList.append(QString("        .%1(%2)").arg(paramName).arg(paramValue));
                }

                out << paramList.join(",\n") << "\n    ) ";
            }
        }

        out << instanceName << " (\n";

        /* Get the port connections for this instance */
        QStringList portConnections;

        /* Get module definition to ensure all ports are listed */
        if (moduleManager && moduleManager->isModuleExist(moduleName)) {
            YAML::Node moduleData = moduleManager->getModuleYaml(moduleName);

            if (moduleData["port"] && moduleData["port"].IsMap()) {
                /* Get the existing connections map for this instance */
                QMap<QString, QString> portMap;
                if (instancePortConnections.contains(instanceName)) {
                    portMap = instancePortConnections[instanceName];
                }

                /* Iterate through all ports in the module definition */
                for (auto portIter = moduleData["port"].begin();
                     portIter != moduleData["port"].end();
                     ++portIter) {
                    if (!portIter->first.IsScalar()) {
                        qWarning() << "Warning: Invalid port name in module" << moduleName;
                        continue;
                    }

                    QString portName = QString::fromStdString(portIter->first.as<std::string>());

                    /* Check if this port has a connection */
                    if (portMap.contains(portName)) {
                        QString wireConnection = portMap[portName];
                        portConnections.append(
                            QString("        .%1(%2)").arg(portName).arg(wireConnection));
                    } else {
                        /* Port exists in module but has no connection */
                        QString direction = "signal";
                        QString width     = "";

                        if (portIter->second && portIter->second["direction"]
                            && portIter->second["direction"].IsScalar()) {
                            direction = QString::fromStdString(
                                portIter->second["direction"].as<std::string>());
                        }

                        /* Get port width/type */
                        if (portIter->second && portIter->second["type"]
                            && portIter->second["type"].IsScalar()) {
                            QString type = QString::fromStdString(
                                portIter->second["type"].as<std::string>());

                            /* Strip out 'logic' keyword for Verilog 2001 compatibility */
                            type = type.replace(QRegularExpression("\\blogic(\\s+|\\b)"), "");

                            /* Extract width information if it exists in format [x:y] or [x] */
                            QRegularExpression widthRegex(
                                "\\[\\s*(\\d+)\\s*(?::\\s*(\\d+))?\\s*\\]");
                            auto match = widthRegex.match(type);
                            if (match.hasMatch()) {
                                if (match.captured(2).isEmpty()) {
                                    /* Format [x] */
                                    width = match.captured(0);
                                } else {
                                    /* Format [x:y] */
                                    width = match.captured(0);
                                }
                            }
                        }

                        /* Check for tie attribute in instance's port */
                        bool    hasTie    = false;
                        bool    hasInvert = false;
                        QString tieValue;
                        int     portWidth = 1; /* Default width if not specified */

                        /* Extract port width for bit size validation */
                        if (!width.isEmpty()) {
                            QRegularExpression widthRegex("\\[(\\d+)(?::\\d+)?\\]");
                            auto               match = widthRegex.match(width);
                            if (match.hasMatch()) {
                                bool ok  = false;
                                int  msb = match.captured(1).toInt(&ok);
                                if (ok) {
                                    portWidth = msb + 1; /* [7:0] means 8 bits */
                                }
                            }
                        }

                        /* Check if this port is already connected to any net in the design */
                        bool isConnectedToNet = false;
                        if (netlistData["net"] && netlistData["net"].IsMap()) {
                            for (auto netIter = netlistData["net"].begin();
                                 netIter != netlistData["net"].end() && !isConnectedToNet;
                                 ++netIter) {
                                if (netIter->second.IsMap()
                                    && netIter->second[instanceName.toStdString()]
                                    && netIter->second[instanceName.toStdString()].IsMap()
                                    && netIter->second[instanceName.toStdString()]["port"]
                                    && netIter->second[instanceName.toStdString()]["port"]
                                           .IsScalar()) {
                                    QString connectedPort = QString::fromStdString(
                                        netIter->second[instanceName.toStdString()]["port"]
                                            .as<std::string>());

                                    if (connectedPort == portName) {
                                        isConnectedToNet = true;
                                        break;
                                    }
                                }
                            }
                        }

                        /* Only proceed with tie if port is not connected to a net */
                        if (!isConnectedToNet) {
                            /* Check if instance has tie attribute for this port */
                            if (netlistData["instance"]
                                && netlistData["instance"][instanceName.toStdString()]
                                && netlistData["instance"][instanceName.toStdString()]["port"]
                                && netlistData["instance"][instanceName.toStdString()]["port"]
                                              [portName.toStdString()]) {
                                auto portNode = netlistData["instance"][instanceName.toStdString()]
                                                           ["port"][portName.toStdString()];

                                /* Check for tie attribute */
                                if (portNode["tie"] && portNode["tie"].IsScalar()) {
                                    QString tieStr = QString::fromStdString(
                                        portNode["tie"].as<std::string>());

                                    /* Parse the tie value using our number parser */
                                    QSocNumberInfo numInfo = parseNumber(tieStr);

                                    /* Only apply tie to input ports */
                                    if (direction.toLower() == "input"
                                        || direction.toLower() == "in") {
                                        hasTie = true;

                                        /* Format the tie value */
                                        /* Create a copy of numInfo with adjusted width */
                                        QSocNumberInfo adjustedInfo = numInfo;

                                        /* Special handling for overflow detection */
                                        if (numInfo.errorDetected) {
                                            /* For overflow values, keep the original string representation */
                                            if (numInfo.width > portWidth) {
                                                tieValue = QString(
                                                               "%1 /* FIXME: Value width %2 bits "
                                                               "exceeds port width %3 bits */")
                                                               .arg(numInfo.originalString)
                                                               .arg(numInfo.width)
                                                               .arg(portWidth);
                                            } else {
                                                tieValue = numInfo.originalString;
                                            }
                                        } else {
                                            /* Normal handling for regular values */
                                            adjustedInfo.width            = portWidth;
                                            adjustedInfo.hasExplicitWidth = true;

                                            /* Create a mask for the width */
                                            BigUnsigned mask = BigUnsigned(0);
                                            for (int i = 0; i < portWidth; i++) {
                                                mask = (mask << 1) + BigUnsigned(1);
                                            }
                                            /* Apply mask to truncate the value */
                                            if (adjustedInfo.value.getSign()
                                                == BigInteger::negative) {
                                                /* For negative numbers, apply mask to magnitude and maintain sign */
                                                BigUnsigned result
                                                    = adjustedInfo.value.getMagnitude() & mask;
                                                adjustedInfo.value
                                                    = BigInteger(result, BigInteger::negative);
                                            } else {
                                                /* For non-negative numbers, just apply the mask */
                                                adjustedInfo.value = BigInteger(
                                                    adjustedInfo.value.getMagnitude() & mask);
                                            }

                                            if (numInfo.width > portWidth) {
                                                /* Value is wider than port - show FIXME comment but use proper width */
                                                tieValue = QString(
                                                               "%1 /* FIXME: Value %2 wider than "
                                                               "port width %3 bits */")
                                                               .arg(adjustedInfo.formatVerilog())
                                                               .arg(numInfo.formatVerilog())
                                                               .arg(portWidth);
                                            } else {
                                                /* Use adjusted formatting with correct width, preserving original base */
                                                tieValue = adjustedInfo.formatVerilog();
                                            }
                                        }

                                        /* Check for invert attribute */
                                        if (portNode["invert"] && portNode["invert"].IsScalar()) {
                                            /* Use direct YAML boolean parsing instead of string conversion */
                                            if (portNode["invert"].as<bool>()) {
                                                /* If we need to invert, apply logical NOT (~) to the value */
                                                tieValue = QString("~(%1)").arg(tieValue);
                                            }
                                        }
                                    } else {
                                        /* Add warning for non-input ports with tie */
                                        tieValue = QString(
                                                       "/* FIXME: 'tie' attribute for %1 port %2 "
                                                       "ignored */")
                                                       .arg(direction.toLower())
                                                       .arg(portName);
                                    }
                                }
                                /* If no tie but has invert attribute on an input port, warn about missing tie */
                                else if (
                                    portNode["invert"] && portNode["invert"].IsScalar()
                                    && (direction.toLower() == "input"
                                        || direction.toLower() == "in")) {
                                    tieValue = QString(
                                                   "/* FIXME: 'invert' attribute on %1 port %2 "
                                                   "without 'tie' attribute */")
                                                   .arg(direction.toLower())
                                                   .arg(portName);
                                }
                            }
                        }

                        /* Format port connection based on connection status and tie attribute */
                        if (hasTie
                            && (direction.toLower() == "input" || direction.toLower() == "in")) {
                            portConnections.append(
                                QString("        .%1(%2)").arg(portName).arg(tieValue));
                        } else {
                            /* Format FIXME message with width if available */
                            if (width.isEmpty()) {
                                portConnections.append(
                                    QString("        .%1(/* FIXME: %2 %3 missing */)")
                                        .arg(portName)
                                        .arg(direction)
                                        .arg(portName));
                            } else {
                                portConnections.append(
                                    QString("        .%1(/* FIXME: %2 %3 %4 missing */)")
                                        .arg(portName)
                                        .arg(direction)
                                        .arg(width)
                                        .arg(portName));
                            }
                        }
                    }
                }
            } else {
                qWarning() << "Warning: Module" << moduleName << "has no valid port section";
            }
        } else {
            qWarning() << "Warning: Failed to get module definition for" << moduleName;

            /* Fall back to existing connections if module definition not available */
            if (instancePortConnections.contains(instanceName)) {
                QMap<QString, QString>        &portMap = instancePortConnections[instanceName];
                QMapIterator<QString, QString> it(portMap);
                while (it.hasNext()) {
                    it.next();
                    portConnections.append(QString("        .%1(%2)").arg(it.key()).arg(it.value()));
                }
            }
        }

        if (portConnections.isEmpty()) {
            /* No port connections found for this instance */
            out << "        /* No port connections found for this instance */\n";
        } else {
            out << portConnections.join(",\n") << "\n";
        }

        out << "    );\n";
    }

    /* Close module */
    out << "\nendmodule\n";

    outputFile.close();
    qInfo() << "Successfully generated Verilog file:" << outputFilePath;

    /* Format generated Verilog file if verible-verilog-format is available */
    formatVerilogFile(outputFilePath);

    return true;
}

bool QSocGenerateManager::formatVerilogFile(const QString &filePath)
{
    /* Check if verible-verilog-format tool is available in the system */
    QProcess which;
    which.start("which", QStringList() << "verible-verilog-format");
    which.waitForFinished();

    if (which.exitCode() != 0) {
        /* Tool not found, silently return */
        qDebug() << "verible-verilog-format not found, skipping formatting";
        return false;
    }

    /* Tool found, proceed with formatting */
    qInfo() << "Formatting Verilog file using verible-verilog-format...";

    QProcess formatter;
    /* clang-format off */
    const QString argsStr = QStaticStringWeaver::stripCommonLeadingWhitespace(R"(
        --inplace
        --column_limit 119
        --indentation_spaces 4
        --line_break_penalty 4
        --wrap_spaces 4
        --port_declarations_alignment align
        --port_declarations_indentation indent
        --formal_parameters_alignment align
        --formal_parameters_indentation indent
        --assignment_statement_alignment align
        --enum_assignment_statement_alignment align
        --class_member_variable_alignment align
        --module_net_variable_alignment align
        --named_parameter_alignment align
        --named_parameter_indentation indent
        --named_port_alignment align
        --named_port_indentation indent
        --struct_union_members_alignment align
    )");
    /* clang-format on */

    QStringList args = argsStr.split(QRegularExpression("\\s+"), Qt::SkipEmptyParts);
    args << filePath;

    formatter.start("verible-verilog-format", args);
    formatter.waitForFinished();

    if (formatter.exitCode() == 0) {
        qInfo() << "Successfully formatted Verilog file";
        return true;
    } else {
        qWarning() << "Error formatting Verilog file:" << formatter.errorString();
        return false;
    }
}

QSocNumberInfo QSocGenerateManager::parseNumber(const QString &numStr)
{
    QSocNumberInfo result;
    result.originalString   = numStr;
    result.base             = QSocNumberInfo::Base::Unknown;
    result.value            = 0;
    result.width            = 0;
    result.hasExplicitWidth = false;
    result.errorDetected    = false;

    /* Remove all underscores from the string (Verilog style) */
    QString cleanStr = numStr;
    cleanStr.remove('_');

    if (cleanStr.isEmpty()) {
        qWarning() << "Empty number string";
        return result;
    }

    /* Check for Verilog-style format with vector range: [31:0] */
    QRegularExpression      vectorWidthRegex(R"(\[(\d+)\s*:\s*(\d+)\])");
    QRegularExpressionMatch vectorWidthMatch = vectorWidthRegex.match(cleanStr);

    if (vectorWidthMatch.hasMatch()) {
        bool msb_ok = false;
        bool lsb_ok = false;
        int  msb    = vectorWidthMatch.captured(1).toInt(&msb_ok);
        int  lsb    = vectorWidthMatch.captured(2).toInt(&lsb_ok);

        if (msb_ok && lsb_ok) {
            result.width            = msb - lsb + 1;
            result.hasExplicitWidth = true;

            /* Remove the vector range from the string for further processing */
            cleanStr.remove(vectorWidthRegex);
        }
    }

    /* Check for Verilog-style format: <width>'<base><value> */
    QRegularExpression      verilogNumberRegex(R"((\d+)'([bdohxBDOHX])([0-9a-fA-F]+))");
    QRegularExpressionMatch verilogMatch = verilogNumberRegex.match(cleanStr);

    if (verilogMatch.hasMatch()) {
        /* Extract width, base, and value from the Verilog format */
        bool widthOk = false;
        int  width   = verilogMatch.captured(1).toInt(&widthOk);

        if (widthOk && !result.hasExplicitWidth) {
            result.width            = width;
            result.hasExplicitWidth = true;
        }

        QChar   baseChar = verilogMatch.captured(2).at(0).toLower();
        QString valueStr = verilogMatch.captured(3);

        /* Determine the base from the base character */
        switch (baseChar.toLatin1()) {
        case 'b': /* Binary */
            result.base = QSocNumberInfo::Base::Binary;
            try {
                result.value = QSocNumberInfo::stringToBigIntegerWithBase(valueStr.toStdString(), 2);
            } catch (const std::exception &e) {
                result.errorDetected = true;
                qWarning() << "Binary value error, using original string:" << numStr
                           << "Error:" << e.what();
            }
            break;
        case 'o': /* Octal */
            result.base = QSocNumberInfo::Base::Octal;
            try {
                result.value = QSocNumberInfo::stringToBigIntegerWithBase(valueStr.toStdString(), 8);
            } catch (const std::exception &e) {
                result.errorDetected = true;
                qWarning() << "Octal value error, using original string:" << numStr
                           << "Error:" << e.what();
            }
            break;
        case 'd': /* Decimal */
            result.base = QSocNumberInfo::Base::Decimal;
            try {
                result.value
                    = QSocNumberInfo::stringToBigIntegerWithBase(valueStr.toStdString(), 10);
            } catch (const std::exception &e) {
                result.errorDetected = true;
                qWarning() << "Decimal value error, using original string:" << numStr
                           << "Error:" << e.what();
            }
            break;
        case 'h': /* Hexadecimal */
        case 'x': /* Alternative for Hexadecimal */
            result.base = QSocNumberInfo::Base::Hexadecimal;
            try {
                result.value
                    = QSocNumberInfo::stringToBigIntegerWithBase(valueStr.toStdString(), 16);
            } catch (const std::exception &e) {
                result.errorDetected = true;
                qWarning() << "Hexadecimal value error, using original string:" << numStr
                           << "Error:" << e.what();
            }
            break;
        default:
            qWarning() << "Unknown base character in Verilog number:" << baseChar;
        }
    } else {
        /* Handle standalone Verilog-style base prefixes (without width): 'b, 'h, 'o, 'd */
        QRegularExpression      verilogBaseRegex(R"('([bdohxBDOHX])([0-9a-fA-F]+))");
        QRegularExpressionMatch verilogBaseMatch = verilogBaseRegex.match(cleanStr);

        if (verilogBaseMatch.hasMatch()) {
            QChar   baseChar = verilogBaseMatch.captured(1).at(0).toLower();
            QString valueStr = verilogBaseMatch.captured(2);

            /* Determine the base from the base character */
            switch (baseChar.toLatin1()) {
            case 'b': /* Binary */
                result.base = QSocNumberInfo::Base::Binary;
                try {
                    result.value
                        = QSocNumberInfo::stringToBigIntegerWithBase(valueStr.toStdString(), 2);
                } catch (const std::exception &e) {
                    result.errorDetected = true;
                    qWarning() << "Binary value error, using original string:" << numStr
                               << "Error:" << e.what();
                }
                break;
            case 'o': /* Octal */
                result.base = QSocNumberInfo::Base::Octal;
                try {
                    result.value
                        = QSocNumberInfo::stringToBigIntegerWithBase(valueStr.toStdString(), 8);
                } catch (const std::exception &e) {
                    result.errorDetected = true;
                    qWarning() << "Octal value error, using original string:" << numStr
                               << "Error:" << e.what();
                }
                break;
            case 'd': /* Decimal */
                result.base = QSocNumberInfo::Base::Decimal;
                try {
                    result.value
                        = QSocNumberInfo::stringToBigIntegerWithBase(valueStr.toStdString(), 10);
                } catch (const std::exception &e) {
                    result.errorDetected = true;
                    qWarning() << "Decimal value error, using original string:" << numStr
                               << "Error:" << e.what();
                }
                break;
            case 'h': /* Hexadecimal */
            case 'x': /* Alternative for Hexadecimal */
                result.base = QSocNumberInfo::Base::Hexadecimal;
                try {
                    result.value
                        = QSocNumberInfo::stringToBigIntegerWithBase(valueStr.toStdString(), 16);
                } catch (const std::exception &e) {
                    result.errorDetected = true;
                    qWarning() << "Hexadecimal value error, using original string:" << numStr
                               << "Error:" << e.what();
                }
                break;
            default:
                qWarning() << "Unknown base character in Verilog number:" << baseChar;
            }
        } else {
            /* Try C-style format */
            if (cleanStr.startsWith("0x") || cleanStr.startsWith("0X")) {
                /* Hexadecimal */
                result.base = QSocNumberInfo::Base::Hexadecimal;
                try {
                    result.value = QSocNumberInfo::stringToBigIntegerWithBase(
                        cleanStr.mid(2).toStdString(), 16);
                } catch (const std::exception &e) {
                    result.errorDetected = true;
                    qWarning() << "Hexadecimal value error, using original string:" << numStr
                               << "Error:" << e.what();
                }
            } else if (cleanStr.startsWith("0b") || cleanStr.startsWith("0B")) {
                /* Binary (C++14 style) */
                result.base = QSocNumberInfo::Base::Binary;
                try {
                    result.value = QSocNumberInfo::stringToBigIntegerWithBase(
                        cleanStr.mid(2).toStdString(), 2);
                } catch (const std::exception &e) {
                    result.errorDetected = true;
                    qWarning() << "Binary value error, using original string:" << numStr
                               << "Error:" << e.what();
                }
            } else if (cleanStr.startsWith("0") && cleanStr.length() > 1) {
                /* Octal */
                result.base = QSocNumberInfo::Base::Octal;
                try {
                    result.value
                        = QSocNumberInfo::stringToBigIntegerWithBase(cleanStr.toStdString(), 8);
                } catch (const std::exception &e) {
                    result.errorDetected = true;
                    qWarning() << "Octal value error, using original string:" << numStr
                               << "Error:" << e.what();
                }
            } else {
                /* Decimal */
                result.base = QSocNumberInfo::Base::Decimal;
                try {
                    result.value
                        = QSocNumberInfo::stringToBigIntegerWithBase(cleanStr.toStdString(), 10);
                } catch (const std::exception &e) {
                    result.errorDetected = true;
                    qWarning() << "Failed to parse decimal number, using original string:"
                               << cleanStr << "Error:" << e.what();
                }
            }
        }
    }

    /* Calculate width if not explicitly provided */
    if (!result.hasExplicitWidth) {
        if (result.errorDetected) {
            /* For error values, set a reasonable width based on the original string */
            if (result.originalString.toLower().contains('h')) {
                /* Hex values: each digit is 4 bits */
                int digits = result.originalString.length();
                /* Rough estimate, removing prefix parts */
                result.width = (digits - 3) * 4; /* Assuming format like "N'h..." */
            } else if (result.originalString.toLower().contains('b')) {
                /* Binary values: each digit is 1 bit */
                int digits = result.originalString.length();
                /* Rough estimate, removing prefix parts */
                result.width = digits - 3; /* Assuming format like "N'b..." */
            } else if (result.originalString.toLower().contains('o')) {
                /* Octal values: each digit is 3 bits */
                int digits = result.originalString.length();
                /* Rough estimate, removing prefix parts */
                result.width = (digits - 3) * 3; /* Assuming format like "N'o..." */
            } else {
                /* Decimal values */
                if (result.originalString.length() > 20) {
                    result.width = 128; /* Very large numbers */
                } else if (result.originalString.length() > 10) {
                    result.width = 64; /* Medium large numbers */
                } else {
                    result.width = 32; /* Regular numbers */
                }
            }
        } else if (result.value == 0) {
            result.width = 1; /* Special case for zero */
        } else {
            /* Calculate minimum required width based on the value */
            BigInteger tempValue       = result.value;
            int        calculatedWidth = 0;

            /* Count how many bits are needed */
            while (tempValue != 0) {
                /* Shift right by one bit */
                if (tempValue.getSign() == BigInteger::negative) {
                    BigUnsigned magnitude = tempValue.getMagnitude();
                    magnitude             = magnitude >> 1;
                    tempValue             = BigInteger(magnitude, BigInteger::negative);
                } else {
                    BigUnsigned magnitude = tempValue.getMagnitude();
                    magnitude             = magnitude >> 1;
                    tempValue             = BigInteger(magnitude);
                }
                calculatedWidth++;
            }

            /* Use exact calculated width */
            result.width = calculatedWidth;
        }
    }

    /* Add debug output */
    qDebug() << "Parsed number:" << numStr << "Value:"
             << QString::fromStdString(QSocNumberInfo::bigIntegerToStringWithBase(result.value, 10))
             << "Base:" << static_cast<int>(result.base) << "Width:" << result.width
             << (result.hasExplicitWidth ? "(explicit)" : "(calculated)")
             << (result.errorDetected ? " (error detected)" : "");

    return result;
}
