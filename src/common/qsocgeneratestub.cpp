// SPDX-License-Identifier: Apache-2.0
// SPDX-FileCopyrightText: 2025 Huang Rui <vowstar@gmail.com>

#include "common/qsocgeneratemanager.h"

#include <QCoreApplication>
#include <QDebug>
#include <QDir>
#include <QFile>
#include <QFileInfo>
#include <QRegularExpression>
#include <QTextStream>

#include <fstream>
#include <iostream>

bool QSocGenerateManager::generateStub(
    const QString            &stubName,
    const QRegularExpression &libraryRegex,
    const QRegularExpression &moduleRegex)
{
    /* Check if project manager is valid */
    if (!projectManager) {
        qCritical() << "Error: Project manager is null";
        return false;
    }

    if (!projectManager->isValidOutputPath(true)) {
        qCritical() << "Error: Invalid output path: " << projectManager->getOutputPath();
        return false;
    }

    /* Check if module manager is valid */
    if (!moduleManager) {
        qCritical() << "Error: Module manager is null";
        return false;
    }

    /* Get all module names that match the library and module regex */
    const QStringList allModuleNames = moduleManager->listModule(libraryRegex);
    QStringList       selectedModules;

    for (const QString &moduleName : allModuleNames) {
        if (moduleRegex.match(moduleName).hasMatch()) {
            selectedModules.append(moduleName);
        }
    }

    if (selectedModules.isEmpty()) {
        qCritical() << "Error: No modules found matching the specified criteria";
        return false;
    }

    qInfo() << "Found" << selectedModules.size()
            << "modules matching criteria:" << selectedModules.join(", ");

    /* Generate Verilog stub file */
    if (!generateVerilogStub(stubName, selectedModules)) {
        qCritical() << "Error: Failed to generate Verilog stub file";
        return false;
    }

    /* Generate Lib stub file */
    if (!generateLibStub(stubName, selectedModules)) {
        qCritical() << "Error: Failed to generate Lib stub file";
        return false;
    }

    return true;
}

bool QSocGenerateManager::generateVerilogStub(const QString &stubName, const QStringList &moduleNames)
{
    /* Prepare output file path */
    const QString outputFilePath = QDir(projectManager->getOutputPath()).filePath(stubName + ".v");

    /* Open output file for writing */
    QFile outputFile(outputFilePath);
    if (!outputFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
        qCritical() << "Error: Failed to open output file for writing:" << outputFilePath;
        return false;
    }

    QTextStream out(&outputFile);

    /* Generate file header */
    out << "/**\n";
    out << " * @file " << stubName << ".v\n";
    out << " * @brief Verilog stub file for multiple modules\n";
    out << " *\n";
    out << " * @details This file contains Verilog stub modules.\n";
    out << " *          Auto-generated stub file. Generated by "
        << QCoreApplication::applicationName() << " " << QCoreApplication::applicationVersion()
        << ".\n";
    out << " * NOTE: Auto-generated file, do not edit manually.\n";
    out << " */\n\n";

    /* Generate stub for each module */
    for (const QString &moduleName : moduleNames) {
        if (!moduleManager->isModuleExist(moduleName)) {
            qWarning() << "Warning: Module" << moduleName << "does not exist, skipping";
            continue;
        }

        YAML::Node moduleData = moduleManager->getModuleYaml(moduleName);

        /* Generate module header comment */
        out << "/**\n";
        out << " * @brief " << moduleName << " module stub\n";
        out << " *\n";
        out << " * @details Stub implementation of " << moduleName << " module.\n";

        /* Add parameter documentation if they exist */
        if (moduleData["parameter"] && moduleData["parameter"].IsMap()
            && moduleData["parameter"].size() > 0) {
            out << " *\n";
            out << " * Parameters:\n";
            for (auto paramIter = moduleData["parameter"].begin();
                 paramIter != moduleData["parameter"].end();
                 ++paramIter) {
                if (!paramIter->first.IsScalar()) {
                    continue;
                }
                const QString paramName = QString::fromStdString(paramIter->first.as<std::string>());

                QString paramDescription = paramName;
                if (paramIter->second.IsMap() && paramIter->second["description"]
                    && paramIter->second["description"].IsScalar()) {
                    paramDescription = QString::fromStdString(
                        paramIter->second["description"].as<std::string>());
                }

                out << " * - " << paramName << ": " << paramDescription << "\n";
            }
        }

        out << " */\n";

        /* Generate module declaration */
        out << "module " << moduleName;

        /* Add module parameters if they exist */
        if (moduleData["parameter"] && moduleData["parameter"].IsMap()
            && moduleData["parameter"].size() > 0) {
            out << " #(\n";
            QStringList paramDeclarations;

            for (auto paramIter = moduleData["parameter"].begin();
                 paramIter != moduleData["parameter"].end();
                 ++paramIter) {
                if (!paramIter->first.IsScalar()) {
                    qWarning() << "Warning: Invalid parameter name, skipping";
                    continue;
                }

                const QString paramName = QString::fromStdString(paramIter->first.as<std::string>());

                if (!paramIter->second.IsMap()) {
                    qWarning() << "Warning: Parameter" << paramName
                               << "has invalid format, skipping";
                    continue;
                }

                /* Default to empty for Verilog 2001 */
                QString paramType  = "";
                QString paramValue = "";

                if (paramIter->second["type"] && paramIter->second["type"].IsScalar()) {
                    paramType = QString::fromStdString(paramIter->second["type"].as<std::string>());
                    /* Clean type for Verilog 2001 compatibility */
                    paramType = QSocGenerateManager::cleanTypeForWireDeclaration(paramType);

                    /* Add a space if type isn't empty after processing */
                    if (!paramType.isEmpty() && !paramType.endsWith(" ")) {
                        paramType += " ";
                    }
                }

                if (paramIter->second["value"] && paramIter->second["value"].IsScalar()) {
                    paramValue = QString::fromStdString(
                        paramIter->second["value"].as<std::string>());
                }

                paramDeclarations.append(QString("    parameter %1%2 = %3  /**< %4 */")
                                             .arg(paramType)
                                             .arg(paramName)
                                             .arg(paramValue.isEmpty() ? "0" : paramValue)
                                             .arg(paramName));
            }

            if (!paramDeclarations.isEmpty()) {
                out << paramDeclarations.join(",\n") << "\n";
            }
            out << ")";
        }

        /* Start port list */
        out << " (\n";

        /* Collect all ports for module interface */
        QStringList ports;

        /* Process port section if it exists */
        if (moduleData["port"] && moduleData["port"].IsMap()) {
            for (auto portIter = moduleData["port"].begin(); portIter != moduleData["port"].end();
                 ++portIter) {
                if (!portIter->first.IsScalar()) {
                    qWarning() << "Warning: Invalid port name, skipping";
                    continue;
                }

                const QString portName = QString::fromStdString(portIter->first.as<std::string>());

                if (!portIter->second.IsMap()) {
                    qWarning() << "Warning: Port" << portName << "has invalid format, skipping";
                    continue;
                }

                QString direction = "input";
                QString type      = ""; /* Empty type by default for Verilog 2001 */

                if (portIter->second["direction"] && portIter->second["direction"].IsScalar()) {
                    const QString dirStr = QString::fromStdString(
                                               portIter->second["direction"].as<std::string>())
                                               .toLower();

                    /* Handle both full and abbreviated forms */
                    if (dirStr == "out" || dirStr == "output") {
                        direction = "output";
                    } else if (dirStr == "in" || dirStr == "input") {
                        direction = "input";
                    } else if (dirStr == "inout") {
                        direction = "inout";
                    }
                }

                /* Get port type/width information if present */
                if (portIter->second["type"] && portIter->second["type"].IsScalar()) {
                    type = QString::fromStdString(portIter->second["type"].as<std::string>());
                    /* Clean type for Verilog 2001 compatibility */
                    type = QSocGenerateManager::cleanTypeForWireDeclaration(type);
                }

                /* Get port description if available */
                QString description = portName;
                if (portIter->second["description"] && portIter->second["description"].IsScalar()) {
                    description = QString::fromStdString(
                        portIter->second["description"].as<std::string>());
                }

                /* Add port declaration */
                QString portDeclaration = portName;
                if (!type.isEmpty()) {
                    portDeclaration = type + " " + portName;
                }
                ports.append(QString("    %1 %2    /**< %3 */")
                                 .arg(direction)
                                 .arg(portDeclaration)
                                 .arg(description));
            }
        }

        /* Close module declaration */
        if (!ports.isEmpty()) {
            out << ports.join(",\n") << "\n";
        }
        out << ");\n";

        /* Add stub comment */
        out << "/* It is a stub, not a complete implementation */\n";

        /* Close module */
        out << "endmodule\n\n";
    }

    outputFile.close();
    qInfo() << "Successfully generated Verilog stub file:" << outputFilePath;

    return true;
}

bool QSocGenerateManager::generateLibStub(const QString &stubName, const QStringList &moduleNames)
{
    /* Prepare output file path */
    const QString outputFilePath = QDir(projectManager->getOutputPath()).filePath(stubName + ".lib");

    /* Open output file for writing */
    QFile outputFile(outputFilePath);
    if (!outputFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
        qCritical() << "Error: Failed to open output file for writing:" << outputFilePath;
        return false;
    }

    QTextStream out(&outputFile);

    /* Generate library header */
    out << "library (" << stubName << ")  {\n\n";

    /* General Library Attributes */
    out << "/* General Library Attributes */\n\n";
    out << "  technology (cmos) ;\n";
    out << "  delay_model      : table_lookup;\n";
    out << "  bus_naming_style : \"%s[%d]\";\n";
    out << "  simulation  : true;\n\n\n";

    /* Unit Definition */
    out << "/* Unit Definition */\n\n";
    out << "  time_unit               : \"1ns\";\n";
    out << "  voltage_unit            : \"1V\";\n";
    out << "  current_unit            : \"1mA\";\n";
    out << "  capacitive_load_unit (1,pf);\n";
    out << "  pulling_resistance_unit : \"1kohm\";\n\n";

    /* Added for DesignPower (Power Estimation). */
    out << "/* Added for DesignPower (Power Estimation). */\n";
    out << "  leakage_power_unit : 1pW;\n";
    out << "  default_cell_leakage_power : 1;\n\n";

    out << "slew_lower_threshold_pct_rise :  10 ;\n";
    out << "slew_upper_threshold_pct_rise :  90 ;\n";
    out << "input_threshold_pct_fall      :  50 ;\n";
    out << "output_threshold_pct_fall     :  50 ;\n";
    out << "input_threshold_pct_rise      :  50 ;\n";
    out << "output_threshold_pct_rise     :  50 ;\n";
    out << "slew_lower_threshold_pct_fall :  10 ;\n";
    out << "slew_upper_threshold_pct_fall :  90 ;\n";
    out << "slew_derate_from_library      :  1.0 ;\n\n\n";

    /* User supplied nominals */
    out << "/****************************/\n";
    out << "/** user supplied nominals **/\n";
    out << "/****************************/\n\n";

    out << "nom_voltage     : 1.100;\n";
    out << "nom_temperature : 25.000;\n";
    out << "nom_process     : 1.000;\n\n";

    out << "operating_conditions(\"typical\"){\n";
    out << "process :   1.0\n";
    out << "temperature :  25\n";
    out << "voltage :      1.10\n";
    out << "tree_type : \"balanced_tree\"\n";
    out << "}\n\n";

    out << "default_operating_conditions  : typical\n\n\n";

    /* User supplied defaults */
    out << "/****************************/\n";
    out << "/** user supplied defaults **/\n";
    out << "/****************************/\n\n";

    out << "default_inout_pin_cap           :       0.0100;\n";
    out << "default_input_pin_cap           :       0.0100;\n";
    out << "default_output_pin_cap          :       0.0000;\n";
    out << "default_fanout_load             :       1.0000;\n\n\n";

    /* Generate type declarations for bus widths */
    QSet<int> busWidths;
    for (const QString &moduleName : moduleNames) {
        if (!moduleManager->isModuleExist(moduleName)) {
            continue;
        }

        YAML::Node moduleData = moduleManager->getModuleYaml(moduleName);
        if (moduleData["port"] && moduleData["port"].IsMap()) {
            for (auto portIter = moduleData["port"].begin(); portIter != moduleData["port"].end();
                 ++portIter) {
                if (!portIter->second.IsMap())
                    continue;

                if (portIter->second["type"] && portIter->second["type"].IsScalar()) {
                    QString type = QString::fromStdString(
                        portIter->second["type"].as<std::string>());
                    type = QSocGenerateManager::cleanTypeForWireDeclaration(type);

                    /* Extract width from [N:0] format */
                    const QRegularExpression      widthRegex(R"(\[(\d+):0\])");
                    const QRegularExpressionMatch match = widthRegex.match(type);
                    if (match.hasMatch()) {
                        const int width = match.captured(1).toInt() + 1;
                        busWidths.insert(width);
                    }
                }
            }
        }
    }

    /* Generate type declarations */
    if (!busWidths.isEmpty()) {
        out << "/* Type declarations */\n\n";
        QList<int> sortedWidths = busWidths.values();
        std::sort(sortedWidths.begin(), sortedWidths.end());

        for (const int width : sortedWidths) {
            if (width > 1) {
                out << "  type (DATA" << width << "B)  {\n";
                out << "    base_type : array;\n";
                out << "    data_type : bit;\n";
                out << "    bit_width : " << width << ";\n";
                out << "    bit_from  : " << (width - 1) << ";\n";
                out << "    bit_to    : 0;\n";
                out << "    downto    : true;\n";
                out << "  }\n\n";
            }
        }
        out << "\n\n";
    }

    /* Cell descriptions */
    out << "/* **************************** */\n";
    out << "/* ****  Cell Description  **** */\n";
    out << "/* **************************** */\n";

    /* Standard voltage mapping */
    out << "    voltage_map(DVDD   , 1.1);\n";
    out << "    voltage_map(AVDD   , 1.1);\n";
    out << "    voltage_map(DVSS   , 0);\n";
    out << "    voltage_map(AVSS   , 0);\n\n";

    /* Generate cell for each module */
    for (const QString &moduleName : moduleNames) {
        if (!moduleManager->isModuleExist(moduleName)) {
            continue;
        }

        YAML::Node moduleData = moduleManager->getModuleYaml(moduleName);

        out << "cell (" << moduleName << ")  {\n\n";

        out << "   area            : 100;\n";
        out << "   dont_touch      : true;\n";
        out << "   dont_use        : true;\n";
        out << "   map_only        : true;\n\n";

        /* Standard power pins */
        out << "   pg_pin(AVDD)  {\n";
        out << "           voltage_name : AVDD ;\n";
        out << "           pg_type : primary_power ;\n";
        out << "   }\n\n";

        out << "   pg_pin(AVSS)  {\n";
        out << "           voltage_name : AVSS ;\n";
        out << "           pg_type : primary_ground ;\n";
        out << "   }\n\n";

        out << "   pg_pin(DVDD)  {\n";
        out << "           voltage_name : DVDD ;\n";
        out << "           pg_type : primary_power ;\n";
        out << "   }\n\n";

        out << "   pg_pin(DVSS)  {\n";
        out << "           voltage_name : DVSS ;\n";
        out << "           pg_type : primary_ground ;\n";
        out << "   }\n\n";

        /* Process port section if it exists */
        if (moduleData["port"] && moduleData["port"].IsMap()) {
            for (auto portIter = moduleData["port"].begin(); portIter != moduleData["port"].end();
                 ++portIter) {
                if (!portIter->first.IsScalar() || !portIter->second.IsMap()) {
                    continue;
                }

                const QString portName  = QString::fromStdString(portIter->first.as<std::string>());
                QString       direction = "input";
                QString       type      = "";

                if (portIter->second["direction"] && portIter->second["direction"].IsScalar()) {
                    const QString dirStr = QString::fromStdString(
                                               portIter->second["direction"].as<std::string>())
                                               .toLower();
                    if (dirStr == "out" || dirStr == "output") {
                        direction = "output";
                    } else if (dirStr == "in" || dirStr == "input") {
                        direction = "input";
                    } else if (dirStr == "inout") {
                        direction = "inout";
                    }
                }

                if (portIter->second["type"] && portIter->second["type"].IsScalar()) {
                    type = QString::fromStdString(portIter->second["type"].as<std::string>());
                    type = QSocGenerateManager::cleanTypeForWireDeclaration(type);
                }

                /* Check if this is a bus port */
                const QRegularExpression      busRegex(R"(\[(\d+):0\])");
                const QRegularExpressionMatch busMatch = busRegex.match(type);

                if (busMatch.hasMatch()) {
                    const int width = busMatch.captured(1).toInt() + 1;
                    out << "   bus(" << portName << ") {\n";
                    out << "        bus_type       : \"DATA" << width << "B\";\n";
                    out << "        related_power_pin : DVDD ;\n";
                    out << "        related_ground_pin  : DVSS ;\n\n";

                    for (int i = 0; i < width; i++) {
                        out << "        pin (" << portName << "[" << i << "]) {\n";
                        out << "        direction      : " << direction << ";\n";
                        out << "        capacitance    : 0.02;\n";
                        out << "        }\n\n";
                    }

                    out << "}  /* end of bus " << portName << " */\n\n";
                } else {
                    /* Single bit port */
                    out << "   pin(" << portName << ")  {\n";
                    out << "           direction : " << direction << ";\n";
                    out << "           capacitance : 0.02;\n";
                    out << "           related_power_pin : DVDD ;\n";
                    out << "           related_ground_pin  : DVSS ;\n";
                    out << "   }\n\n";
                }
            }
        }

        out << "}  /* end of cell " << moduleName << " */\n\n";
    }

    /* Close library */
    out << "}  /* end of library */\n";

    outputFile.close();
    qInfo() << "Successfully generated Lib stub file:" << outputFilePath;

    return true;
}
