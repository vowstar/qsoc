= FINITE STATE MACHINE FORMAT
<fsm-format>
The FSM format defines finite state machine blocks that generate structured Verilog FSM code. This section supports both Table-mode FSMs with Moore/Mealy outputs and Microcode-mode FSMs with ROM-based control, providing powerful tools for implementing complex control logic.

== FSM OVERVIEW
<soc-net-fsm-overview>
The `fsm` section is a sequence of FSM items, each describing one finite state machine. The system supports two main FSM architectures:

#figure(
  align(center)[#table(
    columns: (0.3fr, 1fr),
    align: (auto, left),
    table.header([FSM Type], [Description]),
    table.hline(),
    [Table-mode], [State transition tables with Moore/Mealy outputs],
    [Microcode-mode], [ROM-based sequencer with branch decoding],
  )],
  caption: [FSM ARCHITECTURES],
  kind: table,
)

Both architectures support multiple state encodings (binary, onehot, gray) and generate proper three-stage FSM structure:
1. Next-state combinational logic
2. State register with async reset
3. Output combinational logic (Moore/Mealy/Control signals)

== FSM STRUCTURE
<soc-net-fsm-structure>
Each FSM item must have `name`, `clk`, `rst`, and `rst_state` fields, plus architecture-specific fields:

```yaml
fsm:
  - name: controller        # FSM instance name (used for signal prefixes)
    clk: clk               # Clock signal
    rst: rst_n             # Reset signal
    rst_state: IDLE        # Reset state name
    encoding: binary       # State encoding: binary/onehot/gray (optional)
    # Table-mode specific fields:
    trans: { ... }         # State transition table
    moore: { ... }         # Moore output assignments (optional)
    mealy: [ ... ]         # Mealy output assignments (optional)
    # Microcode-mode specific fields:
    fields: { ... }        # ROM bit field definitions
    rom_mode: parameter    # ROM type: parameter/port
    rom: { ... }           # ROM initialization (for parameter mode)
    rom_depth: 32          # ROM depth (for port mode)
```

== TABLE-MODE FSMS
<soc-net-fsm-table>
Table-mode FSMs use explicit state transition tables and are ideal for traditional state machines with clear state flow:

=== Simple Moore FSM
<soc-net-fsm-moore>
```yaml
fsm:
  - name: cpu_ctrl
    clk: clk
    rst: rst_n
    rst_state: IDLE
    trans:
      IDLE: [{cond: start, next: LOAD}]
      LOAD: [{cond: done_load, next: RUN}]
      RUN: [{cond: done, next: IDLE}]
    moore:
      IDLE: {busy: 0}
      LOAD: {busy: 1}
      RUN: {busy: 1}
```

=== Moore and Mealy FSM
<soc-net-fsm-mealy>
```yaml
fsm:
  - name: spi_rx
    clk: clk
    rst: rst_n
    rst_state: IDLE
    trans:
      IDLE:
        - {cond: "cs_n==0", next: SHIFT}
      SHIFT:
        - {cond: "bit_cnt==7", next: DONE}
        - {cond: "1", next: SHIFT}
      DONE:
        - {cond: "cs_n==1", next: IDLE}
    moore:
      SHIFT: {shift_en: 1}
    mealy:
      - {cond: "spi_rx_cur_state==SPI_RX_DONE && cs_n==1",
         sig: byte_ready, val: 1}
```

=== State Encodings
<soc-net-fsm-encodings>
Different state encodings can be specified to optimize for different requirements:

```yaml
fsm:
  - name: test_onehot
    clk: clk
    rst: rst_n
    rst_state: S0
    encoding: onehot
    trans:
      S0: [{cond: trigger, next: S1}]
      S1: [{cond: trigger, next: S2}]
      S2: [{cond: trigger, next: S0}]
    moore:
      S1: {onehot_output: 1}
  - name: test_gray
    clk: clk
    rst: rst_n
    rst_state: A
    encoding: gray
    trans:
      A: [{cond: trigger, next: B}]
      B: [{cond: trigger, next: C}]
      C: [{cond: trigger, next: A}]
    moore:
      B: {gray_output: 1}
```

Generated Verilog for onehot encoding:
```verilog
module test_onehot (
    /* FSM clock and reset */
    input  clk,        /**< FSM clock input */
    input  rst_n,      /**< FSM reset input */
    /* Input signals */
    input  trigger,    /**< Input signal */
    /* Output signals */
    output onehot_output /**< Output signal */
);

    /* test_onehot : Table FSM generated by YAML-DSL */
    /* test_onehot state registers */
    reg [2:0] test_onehot_cur_state, test_onehot_nxt_state;

    localparam TEST_ONEHOT_S0 = 3'd1;
    localparam TEST_ONEHOT_S1 = 3'd2;
    localparam TEST_ONEHOT_S2 = 3'd4;

    /* test_onehot next-state logic */
    always @(*) begin
        test_onehot_nxt_state = test_onehot_cur_state;
        case (test_onehot_cur_state)
            TEST_ONEHOT_S0: if (trigger) test_onehot_nxt_state = TEST_ONEHOT_S1;
            TEST_ONEHOT_S1: if (trigger) test_onehot_nxt_state = TEST_ONEHOT_S2;
            TEST_ONEHOT_S2: if (trigger) test_onehot_nxt_state = TEST_ONEHOT_S0;
        endcase
    end

    /* test_onehot state register */
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            test_onehot_cur_state <= TEST_ONEHOT_S0;
        end else begin
            test_onehot_cur_state <= test_onehot_nxt_state;
        end
    end

    /* test_onehot Moore output logic */
    assign onehot_output = (test_onehot_cur_state == TEST_ONEHOT_S1);

endmodule
```

=== Complete FSM Example with Multiple Encodings
<soc-net-fsm-multiple-encodings>
Here's a comprehensive example showing multiple FSMs with different state encodings operating together:

```yaml
fsm:
  - name: test_onehot
    clk: clk
    rst: rst_n
    rst_state: S0
    encoding: onehot
    trans:
      S0: [{cond: trigger, next: S1}]
      S1: [{cond: trigger, next: S2}]
      S2: [{cond: trigger, next: S0}]
    moore:
      S1: {onehot_output: 1}
  - name: test_gray
    clk: clk
    rst: rst_n
    rst_state: A
    encoding: gray
    trans:
      A: [{cond: trigger, next: B}]
      B: [{cond: trigger, next: C}]
      C: [{cond: trigger, next: A}]
    moore:
      B: {gray_output: 1}
```

Generated Verilog modules:
```verilog
module test_onehot (
    /* FSM clock and reset */
    input  clk,        /**< FSM clock input */
    input  rst_n,      /**< FSM reset input */
    /* Input signals */
    input  trigger,    /**< Input signal */
    /* Output signals */
    output onehot_output /**< Output signal */
);

    /* test_onehot : Table FSM generated by YAML-DSL */
    /* test_onehot state registers */
    reg [2:0] test_onehot_cur_state, test_onehot_nxt_state;

    localparam TEST_ONEHOT_S0 = 3'd1;
    localparam TEST_ONEHOT_S1 = 3'd2;
    localparam TEST_ONEHOT_S2 = 3'd4;

    /* test_onehot next-state logic */
    always @(*) begin
        test_onehot_nxt_state = test_onehot_cur_state;
        case (test_onehot_cur_state)
            TEST_ONEHOT_S0: if (trigger) test_onehot_nxt_state = TEST_ONEHOT_S1;
            TEST_ONEHOT_S1: if (trigger) test_onehot_nxt_state = TEST_ONEHOT_S2;
            TEST_ONEHOT_S2: if (trigger) test_onehot_nxt_state = TEST_ONEHOT_S0;
            default: test_onehot_nxt_state = test_onehot_cur_state;
        endcase
    end

    /* test_onehot state register w/ async reset */
    always @(posedge clk or negedge rst_n)
        if (!rst_n) test_onehot_cur_state <= TEST_ONEHOT_S0;
        else test_onehot_cur_state <= test_onehot_nxt_state;

    /* test_onehot Moore outputs */
    reg test_onehot_onehot_output_reg;

    assign onehot_output = test_onehot_onehot_output_reg;

    always @(*) begin
        test_onehot_onehot_output_reg = 1'b0;
        case (test_onehot_cur_state)
            TEST_ONEHOT_S1: begin
                test_onehot_onehot_output_reg = 1'b1;
            end
            default: begin
                test_onehot_onehot_output_reg = 1'b0;
            end
        endcase
    end

endmodule

module test_gray (
    /* FSM clock and reset */
    input  clk,        /**< FSM clock input */
    input  rst_n,      /**< FSM reset input */
    /* Input signals */
    input  trigger,    /**< Input signal */
    /* Output signals */
    output gray_output /**< Output signal */
);

    /* test_gray : Table FSM generated by YAML-DSL */
    /* test_gray state registers */
    reg [1:0] test_gray_cur_state, test_gray_nxt_state;

    localparam TEST_GRAY_A = 2'd0;
    localparam TEST_GRAY_B = 2'd1;
    localparam TEST_GRAY_C = 2'd3;

    /* test_gray next-state logic */
    always @(*) begin
        test_gray_nxt_state = test_gray_cur_state;
        case (test_gray_cur_state)
            TEST_GRAY_A: if (trigger) test_gray_nxt_state = TEST_GRAY_B;
            TEST_GRAY_B: if (trigger) test_gray_nxt_state = TEST_GRAY_C;
            TEST_GRAY_C: if (trigger) test_gray_nxt_state = TEST_GRAY_A;
            default: test_gray_nxt_state = test_gray_cur_state;
        endcase
    end

    /* test_gray state register w/ async reset */
    always @(posedge clk or negedge rst_n)
        if (!rst_n) test_gray_cur_state <= TEST_GRAY_A;
        else test_gray_cur_state <= test_gray_nxt_state;

    /* test_gray Moore outputs */
    reg test_gray_gray_output_reg;

    assign gray_output = test_gray_gray_output_reg;

    always @(*) begin
        test_gray_gray_output_reg = 1'b0;
        case (test_gray_cur_state)
            TEST_GRAY_B: begin
                test_gray_gray_output_reg = 1'b1;
            end
            default: begin
                test_gray_gray_output_reg = 1'b0;
            end
        endcase
    end

endmodule

module test_fsm_encodings (
    input  clk,
    input  rst_n,
    input  trigger,
    output onehot_output,
    output gray_output
);

    /* Wire declarations */
    /* Module instantiations */
    test_onehot u_test_onehot (
        .clk(clk),
        .rst_n(rst_n),
        .trigger(trigger),
        .onehot_output(onehot_output)
    );

    test_gray u_test_gray (
        .clk(clk),
        .rst_n(rst_n),
        .trigger(trigger),
        .gray_output(gray_output)
    );

endmodule
```

== MICROCODE-MODE FSMS
<soc-net-fsm-microcode>
Microcode-mode FSMs use ROM-based sequencers with branch decoding, ideal for complex control units and microprocessors:

=== Fixed ROM (Parameter mode)
<soc-net-fsm-microcode-parameter>
```yaml
fsm:
  - name: mseq_fixed
    clk: clk
    rst: rst_n
    rst_state: 0           # Numeric state for microcode
    fields:
      ctrl: [0, 7]         # Control field bits [7:0]
      branch: [8, 9]       # Branch field bits [9:8]
      next: [10, 14]       # Next address field bits [14:10]
    rom_mode: parameter    # ROM implemented as parameters
    rom:
      0: {ctrl: 0x55, branch: 0, next: 1}
      1: {ctrl: 0x3C, branch: 1, next: 4}
      2: {ctrl: 0x18, branch: 0, next: 3}
```

=== Programmable ROM (Port mode)
<soc-net-fsm-microcode-port>
```yaml
fsm:
  - name: mseq_prog
    clk: clk
    rst: rst_n
    rst_state: 0
    rom_mode: port         # ROM with write port
    rom_depth: 32          # 32-word ROM
    fields:
      ctrl: [0, 7]
      branch: [8, 9]
      next: [10, 14]
    # ROM programmed via external ports:
    # mseq_prog_rom_we, mseq_prog_rom_addr, mseq_prog_rom_wdata
```

== FSM PROPERTIES
<soc-net-fsm-properties>

=== Required Fields
<soc-net-fsm-required>
- `name`: FSM instance name (string) - used for signal prefixes
- `clk`: Clock signal name (string)
- `rst`: Reset signal name (string)
- `rst_state`: Reset state name (string/number)

=== Optional Fields
<soc-net-fsm-optional>
- `encoding`: State encoding type (`binary`/`onehot`/`gray`, default: `binary`)

=== Table-mode Fields
<soc-net-fsm-table-fields>
- `trans`: State transition table (map of state -> list of transitions)
  - Each transition: `{cond: "condition", next: "next_state"}`
- `moore`: Moore output assignments (map of state -> output assignments)
- `mealy`: Mealy output assignments (list of conditional assignments)
  - Each assignment: `{cond: "condition", sig: "signal", val: "value"}`

=== Microcode-mode Fields
<soc-net-fsm-microcode-fields>
- `fields`: ROM bit field definitions (map of field -> `[low_bit, high_bit]`)
- `rom_mode`: ROM implementation (`parameter`/`port`)
- `rom`: ROM initialization data (for parameter mode)
- `rom_depth`: ROM depth in words (for port mode)

== FSM VALIDATION
<soc-net-fsm-validation>
The system performs comprehensive validation of FSM specifications:

=== Common Validation
<soc-net-fsm-validation-common>
- FSM name must be unique within the design
- Clock and reset signals must be declared in ports
- Reset state must exist in the state space

=== Table-mode Validation
<soc-net-fsm-validation-table>
- All states referenced in transitions must be defined
- Transition conditions must be valid Verilog expressions
- Moore/Mealy output signals must be declared in ports
- No duplicate state names within an FSM

=== Microcode-mode Validation
<soc-net-fsm-validation-microcode>
- ROM fields must not overlap in bit ranges
- ROM addresses must be within the specified depth
- Field values must fit within their bit ranges
- Branch decoding must reference valid condition signals

== BEST PRACTICES
<soc-net-fsm-practices>

=== Naming Conventions
<soc-net-fsm-naming>
- Use descriptive FSM names: `cpu_ctrl`, `spi_master`, `dma_engine`
- Use meaningful state names: `IDLE`, `FETCH`, `DECODE`, `EXECUTE`
- Group related FSMs with consistent prefixes

=== Design Guidelines
<soc-net-fsm-design>
- Use Table-mode for clear state-based control
- Use Microcode-mode for complex instruction sequences
- Choose appropriate encoding: binary (compact), onehot (fast), gray (low power)
- Keep state count reasonable (< 16 states for table-mode)
- Use meaningful condition expressions

== CODE GENERATION
<soc-net-fsm-generation>
FSM controllers generate standalone modules that are placed at the beginning of the Verilog file, providing structured control flow implementation and module reusability.

=== Generated Code Structure
<soc-net-fsm-code-structure>
1. State type definitions (for table-mode)
2. State registers and next-state signals
3. ROM arrays and initialization (for microcode-mode)
4. Next-state combinational logic
5. State register with async reset
6. Output combinational logic (Moore/Mealy/Control)

=== Naming Conventions
<soc-net-fsm-code-naming>
All generated signals use the FSM name as prefix:
- `{fsm_name}_cur_state`, `{fsm_name}_nxt_state` (table-mode)
- `{fsm_name}_pc`, `{fsm_name}_nxt_pc` (microcode-mode)
- `{fsm_name}_rom` (microcode-mode)

=== Verilog Generation Standards
<soc-net-fsm-verilog-standards>
1. *Verilog 2005 Compliance*: All output signals use internal register pattern with `_reg` suffix and continuous assign statements to ensure compatibility.

2. *FSM Naming Conventions*: FSM-generated signals use lowercase FSM names with underscores (e.g., `test_onehot_cur_state`), while state constants use uppercase (e.g., `TEST_ONEHOT_S0`).

3. *Internal Register Pattern*: Both combinational and sequential logic outputs use internal registers followed by assign statements for proper wire/reg type separation.

4. *Bit Width Inference*: The system automatically infers correct bit widths from port declarations and applies them to internal registers.

5. *ROM Initialization*: Microcode FSMs properly initialize ROM contents with correct bit width padding (e.g., `{5'd1, 2'd0, 8'h55}` for 15-bit ROM words).

6. *Expression Handling*: Sequential logic expressions correctly reference output ports (e.g., `shift_reg << 1` refers to the output port, not the internal register).
